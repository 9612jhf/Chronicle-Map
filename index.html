<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Chronicle-map by OpenHFT</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Chronicle-map</h1>
        <p>Chronicle Map</p>

        <p class="view"><a href="https://github.com/OpenHFT/Chronicle-Map">View the Project on GitHub <small>OpenHFT/Chronicle-Map</small></a></p>


        <ul>
          <li><a href="https://github.com/OpenHFT/Chronicle-Map/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/OpenHFT/Chronicle-Map/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/OpenHFT/Chronicle-Map">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><em>We can help you get Chronicle up and running in your organisation, we suggest you invite us in for
consultancy, charged on an ad-hoc basis, we can discuss the best options tailored to your individual
requirements. - <a href="http://openhft.net/support/">Contact Us</a></em></p>

<p><em>Or you may already be using Chronicle and just want some help - <a href="http://openhft.net/support/">find out more..</a></em></p>

<h1>
<a id="chronicle-map" class="anchor" href="#chronicle-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chronicle Map</h1>

<p>A low latency replicated Key Value Store across your network, with eventual consistency, persistence and performance.
<img src="http://openhft.net/wp-content/uploads/2014/07/ChronicleMap_200px.png" alt="Chronicle Map"></p>

<h4>
<a id="maven-artifact-download" class="anchor" href="#maven-artifact-download" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maven Artifact Download</h4>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">dependency</span>&gt;                                   
  &lt;<span class="pl-ent">groupId</span>&gt;net.openhft&lt;/<span class="pl-ent">groupId</span>&gt;
  &lt;<span class="pl-ent">artifactId</span>&gt;chronicle-map&lt;/<span class="pl-ent">artifactId</span>&gt;
  &lt;<span class="pl-ent">version</span>&gt;<span class="pl-c">&lt;!--replace with the latest version--&gt;</span>&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre></div>

<p>Click here to get the <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22net.openhft%22%20AND%20a%3A%22chronicle-map%22">Latest Version Number</a> </p>

<h4>
<a id="contents" class="anchor" href="#contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contents</h4>

<ul>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#overview">Overview</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#should-i-use-chroniclequeue-or-chroniclemap">Should I use Chronicle Queue or Chronicle Map</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#what-is-the-difference-between-sharedhashmap-and-chroniclemap">What is the difference between SharedHashMap and Chronicle Map</a></li>
<li><a href="http://openhft.github.io/Chronicle-Map/apidocs">JavaDoc</a></li>
<li>
<a href="https://github.com/OpenHFT/Chronicle-Map#getting-started">Getting Started Guide</a>

<ul>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map#simple-construction">Simple Construction</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#maven-artifact-download-1">Maven Download</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#maven-snapshot-download">Snapshot Download</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#key-value-object-types">Key Value Object Types</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#off-heap-storage-and-how-using-a-proxy-object-can-improve-performance">Off Heap and How to improve performance</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#sharing-data-between-two-or-more-maps">Sharing Data Between Two or More Maps</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#entries">Entries</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#size-of-space-reserved-on-disk">Size of Space Reserved on Disk</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#chronicle-map-interface">Chronicle Map Interface</a>
</li>
</ul>
</li>
<li>
<a href="https://github.com/OpenHFT/Chronicle-Map#serialization">Serialization</a>

<ul>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#simple-types">Simple Types</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#complex-types">Complex Types</a>
</li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#importexport-entries-as-json">Import/Export entries as JSON</a>
</li>
</ul>
</li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#close">Close</a></li>
<li>
<a href="https://github.com/OpenHFT/Chronicle-Map#tcp--udp-replication">TCP / UDP Replication</a>

<ul>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#tcp--udp-background">TCP / UDP Background.</a></li>
<li>  <a href="https://github.com/OpenHFT/Chronicle-Map#how-to-setup-udp-replication">How to setup UDP Replication</a>
</li>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map#tcpip--throttling">TCP/IP Throttling</a>
</li>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map#replication-how-it-works">Replication How it works</a>
</li>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map#multiple-processes-on-the-same-server-with-replication">Multiple Processes on the same server with Replication</a>
</li>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map#identifier-for-replication">Identifier for Replication</a>
</li>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map#bootstrapping">Bootstrapping</a>
</li>
<li>   <a href="https://github.com/OpenHFT/Chronicle-Map#identifier">Identifier</a>
</li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#port">Port</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#heart-beat-interval">Heart Beat Interval</a></li>
</ul>
</li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#multiple-chronicle-maps---network-distributed">Multi Chronicle Maps - Network Distributed</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#stateless-client">Stateless Client</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#how-to-speed-up-the-chronicle-map-stateless-client">How to speed up the Chronicle Map Stateless Client</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#questions-and-answers">Questions/Answers</a></li>
</ul>

<h4>
<a id="miscellaneous" class="anchor" href="#miscellaneous" aria-hidden="true"><span class="octicon octicon-link"></span></a>Miscellaneous</h4>

<ul>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#known-issues">Known Issues</a></li>
<li><a href="http://stackoverflow.com/tags/chronicle/info">Stackoverflow</a></li>
<li><a href="https://higherfrequencytrading.atlassian.net/browse/HCOLL">Development Tasks - JIRA</a></li>
<li><a href="http://openhft.net/products/chronicle-engine/">Use Case Which include Chronicle Map</a></li>
</ul>

<h4>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h4>

<ul>
<li><a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/README.md#example--simple-hello-world">Hello World - A map which stores data off heap</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/README.md#example--sharing-the-map-on-two--or-more--processes-on-the-same-machine">Sharing the map between two ( or more ) processes on the same computer</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/README.md#example--replicating-data-between-process-on-different-servers-via-tcp">Replicating data between process on different servers with TCP/IP Replication</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/README.md#example--replicating-data-between-process-on-different-servers-using-udp">Replicating data between process on different servers with UDP</a></li>
<li> <a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/README.md#example--creating-a-chronicle-set-and-adding-data-to-it">Creating a Chronicle Set and adding data to it</a>
</li>
</ul>

<h4>
<a id="performance-topics" class="anchor" href="#performance-topics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance Topics</h4>

<ul>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#chronicle-map-with-large-data">Chronicle Map with Large Data </a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/README.md#lock-contention">Lock Contention</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#better-to-use-small-keys">Better to use small keys</a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#concurrenthashmap-v-chroniclemap">ConcurrentHashMap v ChronicleMap</a></li>
</ul>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h3>

<p>Chronicle Map implements the interface <code>java.util.concurrent.ConcurrentMap</code>, however unlike the standard
jdk implementations, ChronicleMap is both persistent and able to share your entries accross processes:</p>

<p><img src="http://openhft.net/wp-content/uploads/2014/07/Chronicle-Map-diagram_04.jpg" alt=""></p>

<h2>
<a id="when-to-use-hashmap-concurrenthashmap-and-chroniclemap" class="anchor" href="#when-to-use-hashmap-concurrenthashmap-and-chroniclemap" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use HashMap, ConcurrentHashMap and ChronicleMap</h2>

<h4>
<a id="when-to-use-hashmap" class="anchor" href="#when-to-use-hashmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use HashMap</h4>

<p>If you compare <code>HashMap</code>, <code>ConcurrentHashMap</code> and <code>ChronicleMap</code>, most of the maps in your system
are likely to be HashMap.  This is because <code>HashMap</code> is lightweight.  Synchronized HashMap works
well for lightly contended use cases.  By contention we mean, how many threads on average are trying
to use a Map.  One reason you can't have many contended resources, is that you only have so many
CPUs and they can only be accessing a limited resources at once (ideally no more than one or two
per thread at a time).</p>

<h4>
<a id="when-to-use-concurrenthashmap" class="anchor" href="#when-to-use-concurrenthashmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use ConcurrentHashMap</h4>

<p><code>ConcurrentHashMap</code> scales very well when highly contended.  It uses more memory but if you only
have a few of them, this doesn't matter.  They have higher throughput than the other two solutions,
but it does create the highest amount of garbage.  If garbage pressure is an issue for you (for example in 
a low latency evironment), you should consider <code>ChronicleMap</code>.</p>

<h4>
<a id="when-to-use-chroniclemap" class="anchor" href="#when-to-use-chroniclemap" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to use ChronicleMap</h4>

<p>If you have;</p>

<ul>
<li>lots of small key-values</li>
<li>you want to minimise garbage produced, and medium lived objects.</li>
<li>you need to share data between JVMs</li>
<li>you need persistence</li>
</ul>

<h4>
<a id="should-i-use-chroniclequeue-or-chroniclemap" class="anchor" href="#should-i-use-chroniclequeue-or-chroniclemap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Should I use ChronicleQueue or ChronicleMap</h4>

<p>ChronicleQueue is 'lossless', designed to send every update. If your network can't do this something has
to give. You could compress the data but at some point you have to work within the limits of your
hardware or get more hardware. ChronicleMap on the other hand sends the latest value only.
This will naturally drop updates and is a more natural choice for low bandwidth connections.</p>

<h4>
<a id="what-is-the-difference-between-sharedhashmap-and-chroniclemap" class="anchor" href="#what-is-the-difference-between-sharedhashmap-and-chroniclemap" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is the difference between <a href="https://github.com/OpenHFT/HugeCollections">SharedHashMap</a> and ChronicleMap</h4>

<p>SharedHashMap was the old name of what is now ChronicleMap. Since the last release of SharedHashMap
 we have added a lot of new features to ChronicleMap, most of these are listed in this readme.</p>

<h2>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h2>

<h4>
<a id="tutorial-1---creating-an-instance-of-chronicle-map" class="anchor" href="#tutorial-1---creating-an-instance-of-chronicle-map" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tutorial 1 - Creating an instance of Chronicle Map</h4>

<p><a href="http://openhft.net/chronicle-map-video-tutorial-1/"><img src="http://openhft.net/wp-content/uploads/2014/09/Screen-Shot-2014-10-14-at-17.49.36.png" alt="ScreenShot"></a></p>

<h3>
<a id="simple-construction" class="anchor" href="#simple-construction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple Construction</h3>

<p>To download the JAR which contains Chronicle Map, we recommend you use maven, which will download it
from <a href="http://search.maven.org">Maven Central</a>, once you have installed maven, all you have to do is
add the following to your projects <code>pom.xml</code>:</p>

<h4>
<a id="maven-artifact-download-1" class="anchor" href="#maven-artifact-download-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maven Artifact Download</h4>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">dependency</span>&gt;
  &lt;<span class="pl-ent">groupId</span>&gt;net.openhft&lt;/<span class="pl-ent">groupId</span>&gt;
  &lt;<span class="pl-ent">artifactId</span>&gt;chronicle-map&lt;/<span class="pl-ent">artifactId</span>&gt;
  &lt;<span class="pl-ent">version</span>&gt;<span class="pl-c">&lt;!--replace with the latest version--&gt;</span>&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre></div>

<p>To get the latest version number
<a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22net.openhft%22%20AND%20a%3A%22chronicle-map%22">Click Here</a> </p>

<p>when you add ( the above dependency ) to your pom maven will usually attempt to download the release artifacts from: </p>

<pre><code>http://repo1.maven.org/maven2/net/openhft/chronicle-map
</code></pre>

<h4>
<a id="maven-snapshot-download" class="anchor" href="#maven-snapshot-download" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maven Snapshot Download</h4>

<p>If you want to try out the latest pre-release code, you can download the snapshot artifact manually from: </p>

<div class="highlight highlight-xml"><pre>https://oss.sonatype.org/content/repositories/snapshots/net/openhft/chronicle-map/</pre></div>

<p>a better way is to add the following to your setting.xml, to allow maven to download snapshots :</p>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">repository</span>&gt;
    &lt;<span class="pl-ent">id</span>&gt;Snapshot Repository&lt;/<span class="pl-ent">id</span>&gt;
    &lt;<span class="pl-ent">name</span>&gt;Snapshot Repository&lt;/<span class="pl-ent">name</span>&gt;
    &lt;<span class="pl-ent">url</span>&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/<span class="pl-ent">url</span>&gt;
    &lt;<span class="pl-ent">snapshots</span>&gt;
        &lt;<span class="pl-ent">enabled</span>&gt;true&lt;/<span class="pl-ent">enabled</span>&gt;
    &lt;/<span class="pl-ent">snapshots</span>&gt;
&lt;/<span class="pl-ent">repository</span>&gt;</pre></div>

<p>and define the snapshot version in your pom.xml, for example:</p>

<div class="highlight highlight-xml"><pre>&lt;<span class="pl-ent">dependency</span>&gt;
  &lt;<span class="pl-ent">groupId</span>&gt;net.openhft&lt;/<span class="pl-ent">groupId</span>&gt;
  &lt;<span class="pl-ent">artifactId</span>&gt;chronicle-map&lt;/<span class="pl-ent">artifactId</span>&gt;
  &lt;<span class="pl-ent">version</span>&gt;<span class="pl-c">&lt;!--replace with the latest version--&gt;</span>&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre></div>

<h4>
<a id="key-value-object-types" class="anchor" href="#key-value-object-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Key Value Object Types</h4>

<p>Unlike HashMap which will support any heap object, ChronicleMap only works with objects that it 
can store off heap, so the objects have to be  :  (one of the following )</p>

<ul>
<li>AutoBoxed primitives - for good performance.</li>
<li>Strings - for good performance.</li>
<li>implements Serializable<br>
</li>
<li>implements Externalizable ( with a public default constructor ) </li>
<li>implements our custom interface BytesMarshallable ( with a public default constructor ) - use 
this for best performance.</li>
</ul>

<p>or value objects that are created through, a directClass interface, for example : </p>

<div class="highlight highlight-java"><pre>      <span class="pl-st">ChronicleMap&lt;<span class="pl-stj">String</span>, <span class="pl-stj">BondVOInterface</span>&gt;</span> chm <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span>
               .of(<span class="pl-stj">String</span><span class="pl-k">.</span>class, <span class="pl-stj">BondVOInterface</span><span class="pl-k">.</span>class)
               .create();
</pre></div>

<p>Object graphs can also be included as long as the outer object supports Serializable, Externalizable or BytesMarshallable.</p>

<h4>
<a id="chroniclemap-construction" class="anchor" href="#chroniclemap-construction" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChronicleMap Construction</h4>

<p>Creating an instance of ChronicleMap is a little more complex than just calling a constructor.
To create an instance you have to use the ChronicleMapBuilder.</p>

<div class="highlight highlight-java"><pre><span class="pl-k">import</span> <span class="pl-smi">net.openhft.chronicle.map.*</span>
<span class="pl-c1">.....</span>

<span class="pl-k">try</span> {

    <span class="pl-stj">String</span> tmp <span class="pl-k">=</span> <span class="pl-stj">System</span><span class="pl-k">.</span>getProperty(<span class="pl-s1"><span class="pl-pds">"</span>java.io.tmpdir<span class="pl-pds">"</span></span>);
    <span class="pl-stj">String</span> pathname <span class="pl-k">=</span> tmp <span class="pl-k">+</span> <span class="pl-s1"><span class="pl-pds">"</span>/shm-test/myfile.dat<span class="pl-pds">"</span></span>;

    <span class="pl-stj">File</span> file <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">File</span>(pathname);

    <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> builder <span class="pl-k">=</span>
        <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class);
    <span class="pl-st">ConcurrentMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map <span class="pl-k">=</span> builder<span class="pl-k">.</span>createPersistedTo(file);

} <span class="pl-k">catch</span> (<span class="pl-stj">IOException</span> e) {
    e<span class="pl-k">.</span>printStackTrace();
}</pre></div>

<p>ChronicleMap stores its data off the java heap, If you wish to share this off-heap memory between
processes on the same server, you must provide a "file", this file must be the same "file" for all
the instances of Chronicle Map on the same server. The name and location of the "file" is entirely
up to you.  For the best performance on many unix systems we recommend using
<a href="http://en.wikipedia.org/wiki/Tmpfs">tmpfs</a>.</p>

<h3>
<a id="sharing-data-between-two-or-more-maps" class="anchor" href="#sharing-data-between-two-or-more-maps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Data Between Two or More Maps</h3>

<p>Since this file is memory mapped, if you were to create another instance of the ChronicleMap,
pointing to the same file, both ChronicleMaps use this file as a common memory store, into which they
both read and write. The good thing about this, is that the two ( or more instances of the ChronicleMap )
don't have to be running in the same Java process. Ideally and for best performance, the two processes
should be running on the same server. Since the file is memory mapped, ( in most cases ) the read
and writes to the file are hitting the disk cache. This allows the ChronicleMap to exchange data
between processes by just using memory and in around 40 nanoseconds. </p>

<div class="highlight highlight-java"><pre><span class="pl-st">ConcurrentMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map1, map2;

<span class="pl-c">// this could be on one process</span>
map1 <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>createPersistedTo(file);

<span class="pl-c">// this could be on the other process</span>
map2 <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>createPersistedTo(file);</pre></div>

<p>Note: In order to share data between map1 and map2, the file has to point to the same file location
on your server.</p>

<h3>
<a id="entries" class="anchor" href="#entries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Entries</h3>

<p>One of the differences with ChronicleMap against ConcurrentHashMap, is that it can't be resized.
Unlike the ConcurrentHashMap, ChronicleMap is not limited to the available on heap memory.
Resizing is a very expensive operation for HashMaps as it can stall your application, this is why
we don't do it. When you are building a ChronicleMap you can set the maximum number of entries that
you are ever likely to support but it's fine to overestimate this number. This is because ChronicleMap is not
limited to your available memory therefore, at worst, you will end up having a large file on disk.</p>

<p>You set the maximum number of entries using the builder:</p>

<div class="highlight highlight-java"><pre><span class="pl-st">ConcurrentMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map <span class="pl-k">=</span>
    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
    constantValueSizeBySample(<span class="pl-s1"><span class="pl-pds">"</span>a long sample string<span class="pl-pds">"</span></span>),
    .entries(<span class="pl-c1">1000</span>) <span class="pl-c">// set the max number of entries here</span>
    .create();</pre></div>

<p>In this example above we have set 1000 entries.</p>

<p>We have optimised ChronicleMap so that you can have situations where you either don't use;</p>

<ul>
<li><p>All the entries for which you have allowed.  This works best on Unix where the disk space and memory
used reflect the number of actual entries, not the number for which you have allowed.</p></li>
<li><p>All the space you allow for each entry (see below).  This helps if you have entries which are multiple cache
lines (128 bytes +). Only the lines you touch sit in your CPU cache and if you have multiple pages
(8+ Kbytes) only the pages you touch use memory or disk.  The CPU cache usage matters as it can be
10000x smaller than main memory.</p></li>
</ul>

<h4>
<a id="entry-size" class="anchor" href="#entry-size" aria-hidden="true"><span class="octicon octicon-link"></span></a>Entry size</h4>

<p>The size of each entry depends on the type of the Keys and Values, as some types are larger than others. For example, if an entry uses Integers for both the keys and values, both the key and value each take exactly 4 bytes.
There is also some other overhead which is internal to chronicle, such as its internal multi-map, which has an overhead of</p>

<ul>
<li>6 bytes per entry for segment size of &lt; 64k,</li>
<li>9 bytes per entry for segment size of &lt; 16m but &gt; 64k</li>
<li>12 bytes per entry for segment size of &gt; 16m entries per segment.</li>
</ul>

<p>Also, if you create a replicated map, there is an additional 10 bytes per entry.</p>

<p>We suggest you don't configure size for constant-sized keys or values, instead you can use the
builder methods .constantKeySizeBySample(sampleKey) and
.constantValueSizeBySample(sampleValue). For common types like Integer we suggest you don't use
these methods, for example ChronicleMap understands that Integer is 4 bytes long, Long is 8, etc.</p>

<h3>
<a id="size-of-space-reserved-on-disk" class="anchor" href="#size-of-space-reserved-on-disk" aria-hidden="true"><span class="octicon octicon-link"></span></a>Size of space reserved on disk</h3>

<p>In Linux, if you looked at the size of the 'file', it will report the used entry size so if you
have just added one entry, it will report the size of this entry. Windows will report
the reserved size, as it reserves the disk space eagerly ( in fact windows also reserves the memory
eagerly as well ) in other words, number-of-entries x entry-size. </p>

<p>so on Linux, if you type</p>

<pre><code># It shows you the extents. 
ls -l &lt;file&gt;

# It shows you how much is actually used.
du &lt;file&gt;
</code></pre>

<p>To illustrate this with an example - On Ubuntu we can create a 100 TB ChronicleMap.  Both <code>top</code> and
<code>ls -l</code> say the process virtual size / file size is 100 TB, however the resident memory via <code>du</code>
says the size is 71 MB after adding 10000 entries. You can see the size actually used with du.</p>

<h3>
<a id="how-operating-systems-differ" class="anchor" href="#how-operating-systems-differ" aria-hidden="true"><span class="octicon octicon-link"></span></a>How Operating Systems differ</h3>

<p>As a pure Java library, the same ChronicleMap Java byte code can be run on Windows, Linux and Mac OSX,
however these operating systems work with memory mapped files differently. These differences effect how
ChronicleMap is able to map memory to a file and hence this can impact the total number of entries that you are
able to configure.</p>

<ul>
<li>Windows allocates memory and disk eagerly. Windows will fail if more than 4 GB is allocated in a single memory
mapping, ( calculated as 4GB = 2^20 * 4 KB pages). Windows doesn't fail when a memory mapped region is mapped, rather it will fail when it is used up. This limitation doesn't apply to newer or server based versions of Windows. Eager memory allocation means you can't map more than free memory, but it should reduce jitter when you use it. In the future we may support multiple mappings to avoid this limitation, but there is no immediate plan to do so.</li>
<li>Linux allocates memory and disk lazily. Linux systems see a performance degradation at around 200% of main memory.</li>
<li>Mac OSX allocates memory lazily and disk eagerly.</li>
</ul>

<p>ChronicleMap allocates head room which is a waste on Windows (Linux's sparse allocation means the head room has little
impact).</p>

<h5>
<a id="for-production" class="anchor" href="#for-production" aria-hidden="true"><span class="octicon octicon-link"></span></a>For production</h5>

<ul>
<li>on Windows we recommend you use map sizes of less than 4 GB each, and less than 50% main memory in total.</li>
<li>on Linux we recommend you use small to large maps of less than double main memory. e.g. if you have a 128 GB server, we recommend you have less than 256 GB of maps on the server.</li>
<li>on Mac OSX, we have no specific recommendations.</li>
</ul>

<h3>
<a id="chroniclemap-interface" class="anchor" href="#chroniclemap-interface" aria-hidden="true"><span class="octicon octicon-link"></span></a>ChronicleMap Interface</h3>

<p>The ChronicleMap interface adds a few methods above and beyond the standard ConcurrentMap.
The ChronicleMapBuilder can also be used to return the ChronicleMap, see the example below :</p>

<div class="highlight highlight-java"><pre><span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map <span class="pl-k">=</span>
    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>create();</pre></div>

<p>One way to achieve good performance is to focus on unnecessary object creation, as this reduces
the amount of work that has to be carried out by the Garbage Collector. As such ChronicleMap
supports the following methods :</p>

<ul>
<li><a href="http://openhft.github.io/Chronicle-Map/apidocs/net/openhft/chronicle/map/ChronicleMap.html#getUsing-K-V-"><code>V getUsing(K key, V value);</code></a></li>
<li><a href="http://openhft.github.io/Chronicle-Map/apidocs/net/openhft/chronicle/map/ChronicleMap.html#acquireUsing-K-V-"><code>V acquireUsing(K key, V value);</code></a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#off-heap-storage-and-how-using-a-proxy-object-can-improve-performance"><code>ReadContext&lt;K, V&gt; getUsingLocked(@NotNull K key, @NotNull V usingValue);</code></a></li>
<li><a href="https://github.com/OpenHFT/Chronicle-Map#acquireusinglocked"><code>WriteContext&lt;K, V&gt; acquireUsingLocked(@NotNull K key, @NotNull V usingValue);</code></a></li>
</ul>

<p>These methods let you provide the object to which the data will be written so that the value used is mutable. For example</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">CharSequence</span> using <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">StringBuilder</span>();
<span class="pl-stj">CharSequence</span> myResult <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsing(<span class="pl-s1"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>, using);
<span class="pl-c">// at this point "using" and "myResult" will both point to the same object</span></pre></div>

<p>The <code>map.getUsing()</code> method is similar to <code>map.get()</code>, but because Chronicle Map stores its data off
heap, if you were to call get("key"), a new object would be created each time. map.getUsing() works
by reusing the heap memory which was used by the original Object "using". This technique provides
you with better control over your object creation.</p>

<p>Exactly like <code>map.getUsing()</code>, <code>map.acquireUsing()</code> will give you back a reference to an value 
based on
a key, but unlike <code>map.getUsing()</code> if there is no entry in the map for this key the entry 
will be added and the value return will we the same value which you provided. ( The section below
 covers both <code>map.getUsing()</code> and <code>map.acquireUsing()</code> in more detail )</p>

<h4>
<a id="off-heap-storage-and-how-using-a-proxy-object-can-improve-performance" class="anchor" href="#off-heap-storage-and-how-using-a-proxy-object-can-improve-performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Off heap storage and how using a Proxy Object can improve performance</h4>

<p>ChronicleMap stores its data off heap. There are some distinct advantages in using off heap data storage</p>

<ul>
<li>When the off heap data is backed by a memory mapped file, the entire map and its contents are automatically persisted. So if you have to restart your system, you won’t lose the content of your map.</li>
<li>Off heap data structures are not visited by the garbage collector.  With on heap maps like HashMap the garbage collector has to scan your entire object graph ( in fact just the live objects ) to remove garbage.  If you are able to keep your on heap footprint low, the garbage collector has a lot less work to do, this in turn will improve performance.</li>
<li>ChronicleMap and its data is serialised so it can be stored in off 
heap (shared) memory. When this memory is shared between processes on the same server, 
ChronicleMap is able to distribute entries between processes with extremely low overhead. 
This is because both processes are sharing the same off heap memory space. Additionaly, since your objects are already stored off heap ( as a series of bytes ), replicating entries over the network adds relatively little overhead.</li>
</ul>

<p>For more information on the benefit's of off heap memory, see our article on - <a href="http://vanillajava.blogspot.co.uk/2014/12/on-heap-vs-off-heap-memory-usage.html">On
heap vs off
heap memory
usage</a></p>

<p>One of the downsides of an off heap map is that whenever you wish to get a value ( on heap ) from an entry
which is off heap, for example calling :</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">Value</span> v <span class="pl-k">=</span> get(key)</pre></div>

<p>that entry has to be deserialised onto the Java heap so that you can use its value just like any other Java object. So if you were to call get(key) ten times, </p>

<div class="highlight highlight-java"><pre><span class="pl-k">for</span>(<span class="pl-st">int</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>;i<span class="pl-k">&lt;=</span><span class="pl-c1">10</span>;i<span class="pl-k">++</span>) {
  <span class="pl-stj">Value</span> v <span class="pl-k">=</span> get(key)
}</pre></div>

<p>this would create 10 separate instances of the value. This is because each time get() is called, the map has to
first create a Object to store the result in and then deserialise the value stored in the off 
heap entry. Assuming you want to get the value back on heap so that you can use it like a normal Java 
value, deserialisation is unavoidable.  Deserialisation has to occur every time, 
( since the value may have been changed by another thread ), but we don’t have to create the 
object each time. This is why we introduced the method <code>getUsing(key,using)</code>. By reducing the number of objects
you create, the amount of work that the garbage collector has to carry out is reduced, 
this in turn may improve overall performance. So back to <code>getUsing(key,using)</code>, if you wish to reuse
and existing object ( in this case the ‘using’ value ), you can instead call :</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">Value</span> using <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">Value</span>();

<span class="pl-k">for</span>(<span class="pl-st">int</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>;i<span class="pl-k">&lt;=</span><span class="pl-c1">10</span>;i<span class="pl-k">++</span>) {
  <span class="pl-stj">Value</span> bond <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsing(key,using); <span class="pl-c">// this won’t create a new value each time.</span>
  <span class="pl-k">assert</span> using <span class="pl-k">==</span> bond; <span class="pl-c">// this will always be the same instance and the Vaule type can not be immutable</span>
}</pre></div>

<p>We can get a further performance improvement if we don't deserialize the whole object, 
but deserialize only the bytes that in which we are actually interested, </p>

<p>Lets assume that we had the following interface :</p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">interface</span> <span class="pl-en">LongValue</span> {
    <span class="pl-st">long</span> <span class="pl-en">getValue</span>();
    <span class="pl-st">void</span> <span class="pl-en">setValue</span>(<span class="pl-st">long</span> <span class="pl-v">value</span>);
}</pre></div>

<p>It is possible to use chronicle as an off heap proxy that can go directly to the memory location off heap and just get back the long that you require. This is especially useful if the value object has a lot of fields in it like the BondVOInterface</p>

<div class="highlight highlight-java"><pre><span class="pl-s">public</span> <span class="pl-s">interface</span> <span class="pl-en">BondVOInterface</span> {
 <span class="pl-c1">...</span> 

    <span class="pl-st">long</span> <span class="pl-en">getIssueDate</span>();
    <span class="pl-st">void</span> <span class="pl-en">setIssueDate</span>(<span class="pl-st">long</span> <span class="pl-v">issueDate</span>);  <span class="pl-c">/* time in millis */</span>

    <span class="pl-st">long</span> <span class="pl-en">getMaturityDate</span>();
    <span class="pl-st">void</span> <span class="pl-en">setMaturityDate</span>(<span class="pl-st">long</span> <span class="pl-v">maturityDate</span>);  <span class="pl-c">/* time in millis */</span>

    <span class="pl-st">double</span> <span class="pl-en">getCoupon</span>();
    <span class="pl-st">void</span> <span class="pl-en">setCoupon</span>(<span class="pl-st">double</span> <span class="pl-v">coupon</span>);

    <span class="pl-stj">String</span> <span class="pl-en">getSymbol</span>();
    <span class="pl-st">void</span> <span class="pl-en">setSymbol</span>(<span class="pl-st">@MaxSize</span>(<span class="pl-c1">20</span>) <span class="pl-stj">String</span> <span class="pl-v">symbol</span>);
 <span class="pl-c1">...</span> 
}</pre></div>

<p>If for example you want to just do the following</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">BondVOInterface</span>  bond <span class="pl-k">=</span> map<span class="pl-k">.</span>get(key);
bond<span class="pl-k">.</span>getCoupon()
</pre></div>

<p>lets say that it is only the <code>coupon</code> field that we are interested in, then its better not to have to
deserialise the whole object that implements the <code>BondVOInterface</code>. The <code>ChronicleMapBuilder</code> will look a the types of keys
 and values that you use, If the value type is a simple accessor/mutator interface that is exposing a non nested pojo, which uses simple types
 like <code>CharSequence</code> and primitives with corresponding get..() and
 set..() methods, Chronicle is able to generate off heap poxies so the whole object is not
 deserialized each
  time it is accessed, The off heap proxies are able to read
and write into
the off heap data structures directly, this reduced serialisation can give you a big performance boost.
See the example below which demonstartes how you can work directly with off heap entries.</p>

<div class="highlight highlight-java"><pre><span class="pl-st">ChronicleMap&lt;<span class="pl-stj">CharSequence</span>, <span class="pl-stj">BondVOInterface</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span>
        .of(<span class="pl-stj">String</span><span class="pl-k">.</span>class, <span class="pl-stj">BondVOInterface</span><span class="pl-k">.</span>class)
        .keySize(<span class="pl-c1">10</span>)
        .create();</pre></div>

<p>by default, builder assume that we are going to work directly with the off heap
entries (<code>DataValueClasses.directClassFor(BondVOInterface.class)</code>).</p>

<p>The value class, in our case <code>BondVOInterface.class</code> is an <code>interface</code> rather than a <code>class</code>,  as before, we can
use the <code>getUsing(key,using)</code> method, but this time we have to create the ‘using’ instance slightly
differently. We call either the <code>map.newValueInstance()</code> or <code>map.newKeyInstance()</code> method.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">BondVOInterface</span> using <span class="pl-k">=</span> map<span class="pl-k">.</span>newValueInstance();</pre></div>

<p>the call to <code>getUsing(key,value)</code> is the same as we had in the earlier example</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">BondVOInterface</span> using <span class="pl-k">=</span> map<span class="pl-k">.</span>newValueInstance();
<span class="pl-stj">BondVOInterface</span>  bond <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsing(key,using);
<span class="pl-k">assert</span> using <span class="pl-k">==</span> bond; <span class="pl-c">// this will always be the same instance</span></pre></div>

<p><code>getUsing(key,using)</code> won’t create any on heap objects, and it won’t deserialize the ‘bond’ entry from off heap to on
heap, all it does is sets the bond as a proxy to the off heap memory, this proxy object was created by
<code>map.newValueInstance()</code>, it allows us access to the fields of our
entry, directly into the off heap storage.</p>

<p>As above, ideally you would reuse the <code>using</code> variable.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">BondVOInterface</span> using <span class="pl-k">=</span> map<span class="pl-k">.</span>newValueInstance();

<span class="pl-k">for</span>(<span class="pl-st">int</span> i<span class="pl-k">=</span><span class="pl-c1">1</span>;i<span class="pl-k">&lt;=</span><span class="pl-c1">10</span>;i<span class="pl-k">++</span>) {
  <span class="pl-stj">BondVOInterface</span> bond <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsing(key,using); <span class="pl-c">// this won’t create a new value each time.</span>
  <span class="pl-st">double</span> coupon <span class="pl-k">=</span> bond<span class="pl-k">.</span>getCoupon()
  <span class="pl-k">assert</span> using <span class="pl-k">==</span> bond; <span class="pl-c">// this will always be the same instance</span>
}</pre></div>

<p>so when you call :</p>

<div class="highlight highlight-java"><pre>bond<span class="pl-k">.</span>getCoupon()</pre></div>

<p>Note: It is only the coupon that gets deserialized.</p>

<p>Just like any other ConcurrentMap, ChronicleMap uses segment locking, if you wish to obtain a read lock
when calling getUsing(key,using) you can do this :</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">BondVOInterface</span>  bond <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsing(key,value);
<span class="pl-k">try</span> (<span class="pl-st">ReadContext&lt;?, <span class="pl-stj">BondVOInterface</span>&gt;</span> context <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsingLocked(key,bond)) {
   <span class="pl-st">long</span> issueDate <span class="pl-k">=</span>  bond<span class="pl-k">.</span>getIssueDate();
   <span class="pl-stj">String</span> symbol <span class="pl-k">=</span> bond<span class="pl-k">.</span>getSymbol();

    <span class="pl-c">// add your logic here ( the lock will ensure this bond can not be changed by another thread )</span>

} <span class="pl-c">// the lock is released here because close() is called</span>
</pre></div>

<p>To ensure that 'issueDate' and 'symbol' can be read atomically, these values
must be read while the segment read lock is in place.</p>

<p>When you call map.getUsingLocked(key,using) we return a ReadContext, the ReadContext extends
AutoCloseable so will automatically unlock the segment when the try block is exited.</p>

<p>If you wish not to use a try block you must manually release the segment lock by calling</p>

<div class="highlight highlight-java"><pre>context<span class="pl-k">.</span>close() <span class="pl-c">//  releases the lock</span></pre></div>

<h4>
<a id="acquireusing" class="anchor" href="#acquireusing" aria-hidden="true"><span class="octicon octicon-link"></span></a>acquireUsing()</h4>

<p>Just like getUsing(), acquireUsing() will also recycle the value you pass it. The following
code snippet is a pattern that you will often come across. <code>acquireUsing(key,value)</code> offers this 
functionality from a single method call, reducing the hash look-ups and making your code run slightly faster.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">V</span> acquireUsing(key,value) {
    <span class="pl-stj">Lock</span> l <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// the segment lock of the map</span>
    l<span class="pl-k">.</span>lock();
    <span class="pl-k">try</span> {
           <span class="pl-stj">V</span> v <span class="pl-k">=</span> map<span class="pl-k">.</span>getUsing(key,value)
           <span class="pl-k">if</span> (v <span class="pl-k">==</span> <span class="pl-c1">null</span>) {
               map<span class="pl-k">.</span>put(key,value); <span class="pl-c">// create a new entry</span>
               <span class="pl-k">return</span> value;
           } <span class="pl-k">else</span>
               <span class="pl-k">return</span> v; <span class="pl-c">// return the value of the existing entry</span>
    } <span class="pl-k">finally</span> {
        l<span class="pl-k">.</span>unlock();
    }
}</pre></div>

<h4>
<a id="acquireusinglocked" class="anchor" href="#acquireusinglocked" aria-hidden="true"><span class="octicon octicon-link"></span></a>acquireUsingLocked()</h4>

<p>If you are only accessing ChronicleMap from a single thread. If you are not doing replication
and don't care about atomic reads. Then its simpler ( and faster ) to use <code>acquireUsing(key,
value)</code> otherwise werecommend you use <code>acquireUsingLocked(key,value)</code> as this gives you atomicity.</p>

<p>The acquireUsingLocked(key,value) method holds a segment write lock, as it will update or put a
new entry into the map, this is unlike getUsingLocked
(key,using) which only holds a segment read lock. Below is an example of how to use
acquireUsingLocked(..,..).</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">BondVOInterface</span> bond <span class="pl-k">=</span> <span class="pl-c1">...</span> <span class="pl-c">// create your instance</span>
<span class="pl-k">try</span> (<span class="pl-st">WriteContext&lt;?, <span class="pl-stj">BondVOInterface</span>&gt;</span> context <span class="pl-k">=</span> map<span class="pl-k">.</span>acquireUsingLocked(<span class="pl-s1"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>, bond)) {
 <span class="pl-k">assert</span> bond <span class="pl-k">==</span>  context<span class="pl-k">.</span>value();

 <span class="pl-st">long</span> issueDate <span class="pl-k">=</span>  bond<span class="pl-k">.</span>getIssueDate();
 <span class="pl-stj">String</span> symbol <span class="pl-k">=</span> bond<span class="pl-k">.</span>getSymbol();

 <span class="pl-k">if</span> (condition)  <span class="pl-c">// based on your own business logic</span>
    context<span class="pl-k">.</span>removeEntry();
}</pre></div>

<p>If after some business logic, in our example after reading the 'issueDate' and
'symbol', you wish to remove the entry, its more efficient to use the 'context' directly to remove the entry. The
'context' is already aware of the entries location in memory. So it will be quicker to call
<code>context.removeEntry()</code> rather than <code>map.remove(key)</code>.</p>

<h2>
<a id="serialization" class="anchor" href="#serialization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serialization</h2>

<p><img src="http://openhft.net/wp-content/uploads/2014/09/Serialization_01.jpg" alt="Serialization"></p>

<p>ChronicleMap stores your data into off heap memory, so when you give it a Key or Value, it will
serialise these objects into bytes.</p>

<h3>
<a id="simple-types" class="anchor" href="#simple-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple Types</h3>

<p>If you are using simple auto boxed objects based on the primitive types, ChronicleMap will
automatically handle the serialisation for you.  </p>

<h3>
<a id="complex-types" class="anchor" href="#complex-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Complex Types</h3>

<p>For anything other than the standard object, the Objects either have to :</p>

<ul>
<li>implement "java.io.Serializable" ( which we don't recommend as this can be slow )</li>
<li>we also support "java.io.Externalizable", we recommend this over Serializable as its usually faster.</li>
<li>or for the best performance implement net.openhft.lang.io.serialization.BytesMarshallable,
an example of how to do this can be found at "IntValue$$Native"</li>
<li>alternatively, you could write a "Custom Marshaller", the custom marshaller can be implemented
for a single type or a number of types.</li>
</ul>

<h3>
<a id="importexport-entries-as-json" class="anchor" href="#importexport-entries-as-json" aria-hidden="true"><span class="octicon octicon-link"></span></a>Import/Export entries as JSON</h3>

<p><img src="http://openhft.net/wp-content/uploads/2014/09/Export-import_04.jpg" alt="Import/Export"></p>

<p>ChronicleMap supports importing and exporting all the entries into a JSON encoded file.</p>

<div class="highlight highlight-java"><pre><span class="pl-st">void</span> getAll(<span class="pl-stj">File</span> toFile) throws <span class="pl-stj">IOException</span>;
<span class="pl-st">void</span> putAll(<span class="pl-stj">File</span> fromFile) throws <span class="pl-stj">IOException</span>;</pre></div>

<p>Only the entries of your map are exported, not the configuration of your map. So care
must be taken to populate the data in to a map of the correct Key/Value type and with enough
available entries. When importing data :</p>

<ul>
<li>entries that are in the map but not in the JSON file will remain untouched.</li>
<li>entries that are in the map and in the JSON file will be updated.</li>
<li>entries that are not in the map but are in the JSON file will be added.</li>
</ul>

<p>In other words importing data into a ChronicleMap works like <code>map.putAll(&lt;JSON entries&gt;)</code>.</p>

<p>When importing data, if you are also writing to the map at the same time, the last update will win.
In other words a write lock is not held for the entire import process.
Importing and exporting the map, is ideal if you wish to:</p>

<ul>
<li>Bulk load data from one ChronicleMap into another.</li>
<li>migrate data between versions of ChronicleMap.</li>
</ul>

<h2>
<a id="close" class="anchor" href="#close" aria-hidden="true"><span class="octicon octicon-link"></span></a>Close</h2>

<p>Unlike ConcurrentHashMap, ChronicleMap stores its data off heap, often in a memory mapped file.
Its recommended that you call close() once you have finished working with a ChronicleMap.</p>

<div class="highlight highlight-java"><pre>map<span class="pl-k">.</span>close()</pre></div>

<p>This is especially important when working with ChronicleMap replication, as failure to call close may prevent
you from restarting a replicated map on the same port. In the event that your application crashes it may not
be possible to call close(). Your operating system will usually close dangling ports automatically,
so although it is recommended that you close() when you have finished with the map,
its not something that you must do, it's just something that we recommend you should do.</p>

<h6>
<a id="warning" class="anchor" href="#warning" aria-hidden="true"><span class="octicon octicon-link"></span></a>WARNING</h6>

<p>If you call close() too early before you have finished working with the map, this can cause
your JVM to crash. Close MUST BE the last thing that you do with the map.</p>

<h1>
<a id="tcp--udp-replication" class="anchor" href="#tcp--udp-replication" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP / UDP Replication</h1>

<p>ChronicleMap supports both TCP and UDP replication</p>

<p><img src="http://openhft.net/wp-content/uploads/2014/07/Chronicle-Map-TCP-Replication_simple_02.jpg" alt="TCP/IP Replication"></p>

<h3>
<a id="tcp--udp-background" class="anchor" href="#tcp--udp-background" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP / UDP Background.</h3>

<p>TCP/IP is a reliable protocol, what this means is that unless you have a network failure or hardware
outage the data is guaranteed to arrive. TCP/IP provides point to point connectivity. So in effect
( over simplified ), if the message was sent to 100 hosts, the message would have to be sent
100 times. With UDP, the message is only sent once. This is ideal if you have a large number of
hosts and you wish to broadcast the same data to each of them.   However, one of the big drawbacks
with UDP is that it's not a reliable protocol. This means, if the UDP message is Broadcast onto
the network, the hosts are not guaranteed to receive it, so they can miss data. Some solutions
attempt to build resilience into UDP, but arguably, this is in effect reinventing TCP/IP.</p>

<h3>
<a id="how-to-setup-udp-replication" class="anchor" href="#how-to-setup-udp-replication" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to setup UDP Replication</h3>

<p>In reality on a good quality wired LAN, when using UDP, you will rarely miss messages. Nevertheless this is
a risk that we suggest you don't take. We suggest that whenever you use UDP replication you use it
in conjunction with a throttled TCP replication, therefore if a host misses a message over UDP, they
will later pick it up via TCP/IP. </p>

<h3>
<a id="tcpip--throttling" class="anchor" href="#tcpip--throttling" aria-hidden="true"><span class="octicon octicon-link"></span></a>TCP/IP  Throttling</h3>

<p>We are careful not to swamp your network with too much TCP/IP traffic, We do this by providing
a throttled version of TCP replication. This works because ChronicleMap only broadcasts the latest
update of each entry. </p>

<h3>
<a id="replication-how-it-works" class="anchor" href="#replication-how-it-works" aria-hidden="true"><span class="octicon octicon-link"></span></a>Replication How it works</h3>

<p>ChronicleMap provides multi master hash map replication. What this means, is that each remote
map, mirrors its changes over to another remote map, neither map is considered
the master store of data. Each map uses timestamps to reconcile changes.
We refer to in instance of a remote map as a node.
A node can be connected to up to 128 other nodes.
The data that is stored locally in each node becomes eventually consistent. So changes made to one
node, for example by calling put(), will be replicated over to the other node. To achieve a high
level of performance and throughput, the call to put() won’t block, 
With ConcurrentHashMap, It is typical to check the return code of some methods to obtain the old
value, for example remove(). Due to the loose coupling and lock free nature of this multi master
implementation,  this return value is only the old value on the nodes local data store. In other
words the nodes are only concurrent locally. Its worth realising that another node performing
exactly the same operation may return a different value. However reconciliation will ensure the maps
themselves become eventually consistent.</p>

<h3>
<a id="reconciliation" class="anchor" href="#reconciliation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reconciliation</h3>

<p>If two ( or more nodes ) receive a change to their maps for the same key but different values, say
by a user of the maps, calling the put(key,value), then, initially each node will update its local
store and each local store will hold a different value. The aim of multi master replication is
to provide eventual consistency across the nodes. So, with multi master whenever a node is changed
it will notify the other nodes of its change. We will refer to this notification as an event.
The event will hold a timestamp indicating the time the change occurred, it will also hold the state
transition, in this case it was a put with a key and value.
Eventual consistency is achieved by looking at the timestamp from the remote node, if for a given
key, the remote nodes timestamp is newer than the local nodes timestamp, then the event from
the remote node will be applied to the local node, otherwise the event will be ignored. Since
none of the nodes is a primary, each node holds information about the other nodes. For this node its
own identifier is referred to as its 'localIdentifier', the identifiers of other nodes are the
'remoteIdentifiers'. On an update or insert of a key/value, this node pushes the information of
the change to the remote nodes. The nodes use non-blocking java NIO I/O and all replication is done
on a single thread. However there is an edge case. If two nodes update their map at the same time
with different values, we have to deterministically resolve which update wins. This is because eventual
consistency mandates that both nodes should end up locally holding the same data. Although it is rare that two remote
nodes receive an update to their maps at exactly the same time for the same key, we have
to handle this edge case.  We can not therefore rely on timestamps alone to reconcile
the updates. Typically the update with the newest timestamp should win, but in this example both
timestamps are the same, and the decision made to one node should be identical to the decision made
to the other. This dilemma is resolved by using a node identifier, the node identifier is a unique
'byte' value that is assigned to each node. When the time stamps are the same the remote node with the
smaller identifier will be preferred.</p>

<h3>
<a id="multiple-processes-on-the-same-server-with-replication" class="anchor" href="#multiple-processes-on-the-same-server-with-replication" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Processes on the same server with Replication</h3>

<p>On a server if you have a number of Java processes and then within each Java process you create an instance of a ChronicleMap which binds to the same underline 'file', they exchange data via shared memory rather than TCP or UDP replication. So if a ChronicleMap which is not performing TCP Replication is updated, this update can be picked up by another ChronicleMap. This other ChronicleMap could be a TCP replicated ChronicleMap. In such an example the TCP replicated ChronicleMap would then push the update to the remote nodes.</p>

<p>Likewise, if the TCP replicated ChronicleMap was to received an update from a remote node, then this update would be immediately available to all the ChronicleMaps on the server.</p>

<h3>
<a id="identifier-for-replication" class="anchor" href="#identifier-for-replication" aria-hidden="true"><span class="octicon octicon-link"></span></a>Identifier for Replication</h3>

<p>If all you are doing is replicating your ChronicleMaps on the same server you don't have to set up
TCP and UDP replication. You also don't have to set the identifiers - as explained earlier this identifier is only for the resolution of conflicts amongst remote servers.</p>

<p>If however you wish to replicate data between 2 or more servers, then ALL of the ChronicleMaps
including those not actively participating in TCP or UDP replication must have the identifier set.
The identifier must be unique to each server. Each ChronicleMap on the same server must have
the same identifier. The reason that all ChronicleMaps must have the identifier set, is because
the memory is laid out slightly differently when using replication, so even if a Map is not actively
performing TCP or UDP replication itself, if it wishes to replicate with one that is, it must have
its memory laid out the same way to be compatible. </p>

<p>If the identifiers are not set up uniquely then the updates will be ignored, as for example
a ChronicleMap set up with the identifiers equals '1', will ignore all events which contain
the remote identifier of '1', in other words Chronicle Map replication is set up to ignore updates
which have originated from itself. This is to avoid the circularity of events.</p>

<p>When setting up the identifier you can use values from 1 to 127. ( see the section above for more
information on identifiers and how they are used in replication. )</p>

<p>The identifier is setup on the builder as follows.</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span> <span class="pl-c1">...</span>
map <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span>
    .of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
    .replication(identifier, tcpConfig)
    .create();</pre></div>

<h3>
<a id="bootstrapping" class="anchor" href="#bootstrapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bootstrapping</h3>

<p>When a node is connected over the network to an active grid of nodes. It must first receive any data
that it does not have from the other nodes. Eventually, all the nodes in the grid have to hold a
copy of exactly the same data. We refer to this initial data load phase as bootstrapping.
Bootstrapping by its very nature is point to point, so it is only performed over TCP replication.
For architectures that wish to use UDP replication it is advised you use TCP Replication as well. A
grid which only uses UDP replication will miss out on the bootstrapping, possibly leaving the nodes
in an inconsistent state. To avoid this, if you would rather reduce the amount of TCP traffic on
your network, we suggest you consider using a throttle TCP replication along with UDP replication.
Bootstrapping is not used when the nodes are on the same server, so for this case, TCP replication
is not required.</p>

<h3>
<a id="identifier" class="anchor" href="#identifier" aria-hidden="true"><span class="octicon octicon-link"></span></a>Identifier</h3>

<p>Each map is allocated a unique identifier</p>

<p>Server 1 has:</p>

<pre><code>.replication((byte) 1, tcpConfigServer1)
</code></pre>

<p>Server 2 has:</p>

<pre><code>.replication((byte) 2, tcpConfigServer2)
</code></pre>

<p>Server 3 has:</p>

<pre><code>.replication((byte) 3, tcpConfigServer3)
</code></pre>

<p>If you fail to allocate a unique identifier replication will not work correctly.</p>

<h3>
<a id="port" class="anchor" href="#port" aria-hidden="true"><span class="octicon octicon-link"></span></a>Port</h3>

<p>Each map must be allocated a unique port, the port has to be unique per server, if the maps are
running on different hosts they could be allocated the same port, but in our example we allocated
them different ports, we allocated map1 port 8076 and map2 port 8077. Currently we don't support
data forwarding, so it important to connect every remote map, to every other remote map, in other
words you can't have a hub configuration where all the data passes through a single map which every
other map is connected to. So currently, if you had 4 servers each with a Chronicle Map, you would
require 6 connections.</p>

<p>In our case we are only using 2 maps, this is how we connected map1 to map 2.</p>

<pre><code>TcpTransportAndNetworkConfig.of(8076, new InetSocketAddress("localhost", 8077))
                    .heartBeatInterval(1, SECONDS);
</code></pre>

<p>you could have put this instruction on map2 instead, like this </p>

<pre><code>TcpTransportAndNetworkConfig.of(8077, new InetSocketAddress("localhost", 8076))
                    .heartBeatInterval(1, SECONDS);
</code></pre>

<p>even though data flows from map1 to map2 and map2 to map1 it doesn't matter which way you connected
this, in other words its a bidirectional connection. </p>

<h3>
<a id="configuring-three-way-tcpip-replication" class="anchor" href="#configuring-three-way-tcpip-replication" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuring Three Way TCP/IP Replication</h3>

<p><img src="http://openhft.net/wp-content/uploads/2014/09/Screen-Shot-2014-10-27-at-18.19.05.png" alt="TCP/IP Replication 3Way"></p>

<p>Below is example how to set up tcpConfig for 3 host</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">String</span> hostServer1 <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>; <span class="pl-c">// change this to your host</span>
<span class="pl-st">int</span> serverPort1 <span class="pl-k">=</span> <span class="pl-c1">8076</span>;           <span class="pl-c">// change this to your port</span>
<span class="pl-stj">InetSocketAddress</span> inetSocketAddress1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(hostServer1, serverPort1);

<span class="pl-stj">String</span> hostServer2 <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>; <span class="pl-c">// change this to your host</span>
<span class="pl-st">int</span>  serverPort2<span class="pl-k">=</span> <span class="pl-c1">8077</span>;           <span class="pl-c">// change this to your port</span>
<span class="pl-stj">InetSocketAddress</span> inetSocketAddress2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(hostServer2, serverPort2);

<span class="pl-stj">String</span> hostServer3 <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>; <span class="pl-c">// change this to your host</span>
<span class="pl-st">int</span> serverPort3 <span class="pl-k">=</span> <span class="pl-c1">8078</span>;           <span class="pl-c">// change this to your port</span>
<span class="pl-stj">InetSocketAddress</span> inetSocketAddress3 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(hostServer3, serverPort3);

<span class="pl-c">// this is to go on server 1</span>
<span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfigServer1 <span class="pl-k">=</span>
        <span class="pl-stj">TcpTransportAndNetworkConfig</span><span class="pl-k">.</span>of(serverPort1);

<span class="pl-c">// this is to go on server 2</span>
<span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfigServer2 <span class="pl-k">=</span> <span class="pl-stj">TcpTransportAndNetworkConfig</span>
        .of(serverPort2, inetSocketAddress1);

<span class="pl-c">// this is to go on server 3</span>
<span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfigServer3 <span class="pl-k">=</span> <span class="pl-stj">TcpTransportAndNetworkConfig</span>
        .of(serverPort3, inetSocketAddress1, inetSocketAddress2);</pre></div>

<h3>
<a id="heart-beat-interval" class="anchor" href="#heart-beat-interval" aria-hidden="true"><span class="octicon octicon-link"></span></a>Heart Beat Interval</h3>

<p>We set a heartBeatInterval, in our example to 1 second</p>

<div class="highlight highlight-java"><pre> heartBeatInterval(<span class="pl-c1">1</span>, <span class="pl-c1">SECONDS</span>)</pre></div>

<p>A heartbeat will only be send if no data is transmitted, if the maps are constantly exchanging data
no heartbeat message is sent. If a map does not receive either data of a heartbeat the connection
is dropped and re-established.</p>

<h1>
<a id="multiple-chronicle-maps---network-distributed" class="anchor" href="#multiple-chronicle-maps---network-distributed" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Chronicle Maps - Network Distributed</h1>

<p><img src="http://openhft.net/wp-content/uploads/2014/07/Chronicle-Map_channels_diagram_02.jpg" alt="Chronicle Maps Network Distributed"></p>

<p>ChronicleMap TCP Replication lets you distribute a single ChronicleMap, to a number of servers
across your network. Replication is point to point and the data transfer is bidirectional, so in the
example of just two servers, they only have to be connected via a single TCP socket connection and
the data is transferred both ways. This is great, but what if you wanted to replicate more than
just one ChronicleMap, what if you were going to replicate two ChronicleMaps across your network,
unfortunately with just TCP replication you would have to have two tcp socket connections, which is
not ideal. This is why we created the <code>ReplicationHub</code>. The <code>ReplicationHub</code> lets you replicate numerous
ChronicleMaps via a single point to point socket connection.</p>

<p>The <code>ReplicationHub</code> encompasses TCP replication, where each map has to be given a
unique identifier, but when using the <code>ReplicationHub</code> we use a channel to identify the map,
rather than the identifier.  The identifier is used to identify the host/server which broadcasts the
update. Put simply:</p>

<ul>
<li>Each host must be given a unique identifier.</li>
<li>Each map must be given a unique channel.</li>
</ul>

<div class="highlight highlight-java"><pre><span class="pl-st">byte</span> identifier<span class="pl-k">=</span> <span class="pl-c1">2</span>;
<span class="pl-stj">ReplicationHub</span> replicationHub <span class="pl-k">=</span> <span class="pl-stj">ReplicationHub</span><span class="pl-k">.</span>builder()
                    .tcpTransportAndNetwork(tcpConfig)
                    .createWithId(identifier);</pre></div>

<p>In this example above the <code>ReplicationHub</code> is given the identifier of 2.</p>

<p>With channels you are able to attach additional maps to a <code>ReplicationChannel</code> once its up and
running.</p>

<p>When creating the <code>ReplicationChannel</code> you should attach your tcp or udp configuration :</p>

<div class="highlight highlight-java"><pre><span class="pl-st">byte</span> identifier <span class="pl-k">=</span> <span class="pl-c1">1</span>;
<span class="pl-stj">ReplicationHub</span> replicationHub <span class="pl-k">=</span> <span class="pl-stj">ReplicationHub</span><span class="pl-k">.</span>builder()
                    .tcpTransportAndNetwork(tcpConfig)
                    .createWithId(identifier);</pre></div>

<p>Attaching a <code>ReplicationChannel</code> to the map :</p>

<div class="highlight highlight-java"><pre><span class="pl-st">short</span> channel <span class="pl-k">=</span> (<span class="pl-st">short</span>) <span class="pl-c1">2</span>;
<span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
  .entries(<span class="pl-c1">1000</span>)
  .instance()<span class="pl-k">.</span>replicatedViaChannel(replicationHub<span class="pl-k">.</span>createChannel(channel))
  .create();</pre></div>

<p>The Chronicle channel is use to identify which map is to be replicated to which other map on
the remote node. In the example above this is assigned to '(short) 1', so for example if you have
two maps, lets call them map1 and map2, you could assign them with chronicle
channels 1 and 2 respectively. Map1 would have the chronicle channel of 1 on both servers. You
should not confuse the Chronicle Channels with the identifiers, the identifiers are unique per
replicating node ( in this case which host, the reason we say replicating node rather than host as it is
possible to have more than one replicating node per host if each of them had a different TCP/IP port ), where as the chronicle channels are used to identify which map you are referring. No additional socket
 connection is made per chronicle channel that
you use, so we allow up to 32767 chronicle channels.</p>

<p>If you inadvertently got the chronicle channels around the wrong way, then chronicle would attempt
to replicate the wrong maps data. The chronicle channels don't have to be in order but they must be
unique for each map you have.</p>

<h3>
<a id="channels-and-replicationchannel---example" class="anchor" href="#channels-and-replicationchannel---example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channels and ReplicationChannel - Example</h3>

<div class="highlight highlight-java"><pre>
<span class="pl-k">import</span> <span class="pl-smi">net.openhft.chronicle.hash.replication.ReplicationChannel</span>;
<span class="pl-k">import</span> <span class="pl-smi">net.openhft.chronicle.hash.replication.ReplicationHub</span>;
<span class="pl-k">import</span> <span class="pl-smi">net.openhft.chronicle.hash.replication.TcpTransportAndNetworkConfig</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.net.InetSocketAddress</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.concurrent.TimeUnit</span>;

<span class="pl-k">import static</span> <span class="pl-smi">org.junit.Assert.assertEquals</span>;

<span class="pl-c1">...</span>

<span class="pl-st">ChronicleMap&lt;<span class="pl-stj">CharSequence</span>, <span class="pl-stj">CharSequence</span>&gt;</span> favoriteColourServer1, favoriteColourServer2;
<span class="pl-st">ChronicleMap&lt;<span class="pl-stj">CharSequence</span>, <span class="pl-stj">CharSequence</span>&gt;</span> favoriteComputerServer1, favoriteComputerServer2;


<span class="pl-c">// server 1 with  identifier = 1</span>
{
    <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">CharSequence</span>, <span class="pl-stj">CharSequence</span>&gt;</span> builder <span class="pl-k">=</span>
            <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>entries(<span class="pl-c1">1000</span>);

    <span class="pl-st">byte</span> identifier <span class="pl-k">=</span> (<span class="pl-st">byte</span>) <span class="pl-c1">1</span>;

    <span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span> <span class="pl-stj">TcpTransportAndNetworkConfig</span>
            .of(<span class="pl-c1">8086</span>, <span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8087</span>))
            .heartBeatInterval(<span class="pl-c1">1</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>SECONDS</span>);

    <span class="pl-stj">ReplicationHub</span> hubOnServer1 <span class="pl-k">=</span> <span class="pl-stj">ReplicationHub</span><span class="pl-k">.</span>builder()
            .tcpTransportAndNetwork(tcpConfig)
            .createWithId(identifier);

    <span class="pl-c">// this demotes favoriteColour</span>
    <span class="pl-st">short</span> channel1 <span class="pl-k">=</span> (<span class="pl-st">short</span>) <span class="pl-c1">1</span>;

    <span class="pl-stj">ReplicationChannel</span> channel <span class="pl-k">=</span> hubOnServer1<span class="pl-k">.</span>createChannel(channel1);
    favoriteColourServer1 <span class="pl-k">=</span> builder<span class="pl-k">.</span>instance()
            .replicatedViaChannel(channel)<span class="pl-k">.</span>create();

    favoriteColourServer1<span class="pl-k">.</span>put(<span class="pl-s1"><span class="pl-pds">"</span>peter<span class="pl-pds">"</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span>);

    <span class="pl-c">// this demotes favoriteComputer</span>
    <span class="pl-st">short</span> channel2 <span class="pl-k">=</span> (<span class="pl-st">short</span>) <span class="pl-c1">2</span>;

    favoriteComputerServer1 <span class="pl-k">=</span> builder<span class="pl-k">.</span>instance()
            .replicatedViaChannel(hubOnServer1<span class="pl-k">.</span>createChannel(channel2))<span class="pl-k">.</span>create();

    favoriteComputerServer1<span class="pl-k">.</span>put(<span class="pl-s1"><span class="pl-pds">"</span>peter<span class="pl-pds">"</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>dell<span class="pl-pds">"</span></span>);
}

<span class="pl-c">// server 2 with  identifier = 2</span>
{
    <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">CharSequence</span>, <span class="pl-stj">CharSequence</span>&gt;</span> builder <span class="pl-k">=</span>
            <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>entries(<span class="pl-c1">1000</span>);

    <span class="pl-st">byte</span> identifier <span class="pl-k">=</span> (<span class="pl-st">byte</span>) <span class="pl-c1">2</span>;

    <span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span> <span class="pl-stj">TcpTransportAndNetworkConfig</span>
            .of(<span class="pl-c1">8087</span>)<span class="pl-k">.</span>heartBeatInterval(<span class="pl-c1">1</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>SECONDS</span>);

    <span class="pl-stj">ReplicationHub</span> hubOnServer2 <span class="pl-k">=</span> <span class="pl-stj">ReplicationHub</span><span class="pl-k">.</span>builder()
            .tcpTransportAndNetwork(tcpConfig)
            .createWithId(identifier);

    <span class="pl-c">// this demotes favoriteColour</span>
    <span class="pl-st">short</span> channel1 <span class="pl-k">=</span> (<span class="pl-st">short</span>) <span class="pl-c1">1</span>;

    favoriteColourServer2 <span class="pl-k">=</span> builder<span class="pl-k">.</span>instance()
            .replicatedViaChannel(hubOnServer2<span class="pl-k">.</span>createChannel(channel1))<span class="pl-k">.</span>create();

    favoriteColourServer2<span class="pl-k">.</span>put(<span class="pl-s1"><span class="pl-pds">"</span>rob<span class="pl-pds">"</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>blue<span class="pl-pds">"</span></span>);

    <span class="pl-c">// this demotes favoriteComputer</span>
    <span class="pl-st">short</span> channel2 <span class="pl-k">=</span> (<span class="pl-st">short</span>) <span class="pl-c1">2</span>;

    favoriteComputerServer2 <span class="pl-k">=</span> builder<span class="pl-k">.</span>instance()
            .replicatedViaChannel(hubOnServer2<span class="pl-k">.</span>createChannel(channel2))<span class="pl-k">.</span>create();

    favoriteComputerServer2<span class="pl-k">.</span>put(<span class="pl-s1"><span class="pl-pds">"</span>rob<span class="pl-pds">"</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>mac<span class="pl-pds">"</span></span>);
    favoriteComputerServer2<span class="pl-k">.</span>put(<span class="pl-s1"><span class="pl-pds">"</span>daniel<span class="pl-pds">"</span></span>, <span class="pl-s1"><span class="pl-pds">"</span>mac<span class="pl-pds">"</span></span>);
}

<span class="pl-c">// allow time for the recompilation to resolve</span>
<span class="pl-k">for</span> (<span class="pl-st">int</span> t <span class="pl-k">=</span> <span class="pl-c1">0</span>; t <span class="pl-k">&lt;</span> <span class="pl-c1">2500</span>; t<span class="pl-k">++</span>) {
    <span class="pl-k">if</span> (favoriteComputerServer2<span class="pl-k">.</span>equals(favoriteComputerServer1) <span class="pl-k">&amp;&amp;</span>
            favoriteColourServer2<span class="pl-k">.</span>equals(favoriteColourServer1))
        <span class="pl-k">break</span>;
    <span class="pl-stj">Thread</span><span class="pl-k">.</span>sleep(<span class="pl-c1">1</span>);
}

assertEquals(favoriteComputerServer1, favoriteComputerServer2);
assertEquals(<span class="pl-c1">3</span>, favoriteComputerServer2<span class="pl-k">.</span>size());

assertEquals(favoriteColourServer1, favoriteColourServer2);
assertEquals(<span class="pl-c1">2</span>, favoriteColourServer1<span class="pl-k">.</span>size());

favoriteColourServer1<span class="pl-k">.</span>close();
favoriteComputerServer2<span class="pl-k">.</span>close();
favoriteColourServer2<span class="pl-k">.</span>close();
favoriteColourServer1<span class="pl-k">.</span>close();
</pre></div>

<h1>
<a id="stateless-client" class="anchor" href="#stateless-client" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stateless Client</h1>

<p><img src="http://openhft.net/wp-content/uploads/2014/07/Chronicle-Map-remote-stateless-map_04_vB.jpg" alt=""></p>

<p>A stateless client is an instance of a <code>ChronicleMap</code> or a <code>ChronicleSet</code> that does not hold any 
data
 locally, all the Map or Set operations are delegated via a Remote Procedure Calls ( RPC ) to 
 another <code>ChronicleMap</code> or  <code>ChronicleSet</code>  which we will refer to as the server. The server
 holds all your data, the server can not it’s self be a stateless client. Your stateless client must
 be connected to the server via TCP/IP.</p>

<p><img src="http://openhft.net/wp-content/uploads/2014/09/State-Transition_1-thread_02.jpg" alt="ChronicleMap"></p>

<p>The stateless client delegates all your method calls to
 the remote server. The stateless client operations will block, in other words the stateless
 client waits for the server to send a response before continuing to the next operation. The stateless
 client could be  consider to be a ClientProxy to <code>ChronicleMap</code> or  <code>ChronicleSet</code>  running
 on another host.</p>

<p>Below is an example of how to configure a stateless client.</p>

<div class="highlight highlight-java"><pre><span class="pl-s">final</span> <span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> serverMap;
<span class="pl-s">final</span> <span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> statelessMap;

<span class="pl-c">// server</span>
{

    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
            .replication((<span class="pl-st">byte</span>) <span class="pl-c1">2</span>, <span class="pl-stj">TcpTransportAndNetworkConfig</span><span class="pl-k">.</span>of(<span class="pl-c1">8076</span>))
            .create();            

    serverMap<span class="pl-k">.</span>put(<span class="pl-c1">10</span>, <span class="pl-s1"><span class="pl-pds">"</span>EXAMPLE-10<span class="pl-pds">"</span></span>);
}

<span class="pl-c">// stateless client</span>
{
    statelessMap <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
            .statelessClient(<span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8076</span>))
            .create();

    <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertEquals(<span class="pl-s1"><span class="pl-pds">"</span>EXAMPLE-10<span class="pl-pds">"</span></span>, statelessMap<span class="pl-k">.</span>get(<span class="pl-c1">10</span>));
    <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertEquals(<span class="pl-c1">1</span>, statelessMap<span class="pl-k">.</span>size());
}

serverMap<span class="pl-k">.</span>close();
statelessMap<span class="pl-k">.</span>close();</pre></div>

<p>When used with a stateless client, each statefull server has to be configured with TCP 
replication, when you set up TCP replication you must define a port for the replication to 
run on, the port you choose is up to you, but you should pick a free port that is not currently 
being used by another application. In this example we choose the port 8076</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// sets the server to run on localhost:8076</span>
.replication((<span class="pl-st">byte</span>) <span class="pl-c1">2</span>, <span class="pl-stj">TcpTransportAndNetworkConfig</span><span class="pl-k">.</span>of(<span class="pl-c1">8076</span>))</pre></div>

<p>On the "stateless client" we connect to the server via TCP/IP on localhost:8076 : </p>

<div class="highlight highlight-java"><pre>.statelessClient(<span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8076</span>))</pre></div>

<p>but in your example you should choose the host of the statefull server and the port you allocated
 it. </p>

<div class="highlight highlight-java"><pre>.statelessClient(<span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-k">&lt;</span>host of state<span class="pl-k">-</span>full server<span class="pl-k">&gt;</span>, <span class="pl-k">&lt;</span>port of state<span class="pl-k">-</span>full server<span class="pl-k">&gt;</span>))</pre></div>

<p>the ".statelessClient(..)" returns an instance of <code>StatelessClientConfig</code>, which has only a few
of its own configurations, such as the <code>create()</code> method, which can be used to create a new
stateless client.
For this example we ran both 
the client and the server on the same host ( hence the “localhost" setting ), 
but in a real scanario the stateless client will typically be on a different server than its
statefull host. If you are aiming to create a stateless client and server on the same host, it's
better not to do this, as the stateless client connects to the server via TCP/IP. It would be better to
share the maps via memory as this will give you better performance ( read more about
this at <a href="https://github%0A.com/OpenHFT/Chronicle-Map#sharing-data-between-two-or-more-maps">Sharing Data Between Two or More Maps</a>.</p>

<p>click <a href="https://github.com/OpenHFT/Chronicle-Map#sharing-data-between-two-or-more-maps">here</a> </p>

<h3>
<a id="how-to-speed-up-the-chronicle-map-stateless-client" class="anchor" href="#how-to-speed-up-the-chronicle-map-stateless-client" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to speed up the Chronicle Map Stateless Client</h3>

<p>When calling the stateless client, you will get better throughput if you invoke your requests from a
 number of threads, this is because by default when you make a method call to a <code>ChronicleMap</code>
 stateless client, your method call is wrapped into an event which is sent over TCP and processed
  by the server. Your stateless client will block until an acknowledgement has been received from the server that
the event was processed.</p>

<p><img src="http://openhft.net/wp-content/uploads/2014/09/State-Transition_2-thread_03.jpg" alt="Chronicle Map"></p>

<p>When you are calling methods that return a value like get() this
blocking adds no additional overhead, because you have to wait for the return value anyway, 
In some cases you could get better performance if you don't have to wait for the acknowledgement, This maybe the case when you are calling the <code>put()</code> method, but the problem with this method is it returns the old value even though you may not use it.</p>

<p>For in memory data-structures like a HashMap this isn’t a big problem. But in a distributed environment things are a bit more complicated. Blocking for an old value that you don’t require adds additional network overhead and additional processing overhead of serialising the old value on the server and deserialising it on the client</p>

<p>So if you don’t require the old value and don’t wish to block until your <code>put()</code> has been received by the server, then you may wish to consider using the following configuration :</p>

<div class="highlight highlight-java"><pre>.putReturnsNull(<span class="pl-c1">true</span>)</pre></div>

<p>and also for the <code>remove()</code> method</p>

<div class="highlight highlight-java"><pre>.removeReturnsNull(<span class="pl-c1">true</span>)</pre></div>

<div class="highlight highlight-java"><pre>statelessClientMap <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
     .putReturnsNull(<span class="pl-c1">true</span>)
     .removeReturnsNull(<span class="pl-c1">true</span>)
     .statelessClient(<span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8076</span>))
     .create();</pre></div>

<p>For the very best performance you should also set these properties on the server as well</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
    .replication((<span class="pl-st">byte</span>) <span class="pl-c1">2</span>, <span class="pl-stj">TcpTransportAndNetworkConfig</span><span class="pl-k">.</span>of(<span class="pl-c1">8076</span>))
    .putReturnsNull(<span class="pl-c1">true</span>)
    .removeReturnsNull(<span class="pl-c1">true</span>)
    .create();            </pre></div>

<h5>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h5>

<p>The throughput and latency performance for different configurations.</p>

<p>Tested using a test called BGChronicleTest.</p>

<p>On one machine (i7 3.5 GHz) we have two persisted replicas run as</p>

<p>-Dreplicas=2 eg.BGChronicleTest server</p>

<p>On another machine (Dual Xeon 8 core 2.6 GHz) connected via a pair of Solarflare SFN5121T 10 Gig-E with onload enabled.</p>

<p>-Dreplicas=2 -Dclients={see below} -DmaxRate=30000 -DreadRatio=2 eg.BGChronicleTest client</p>

<p>2 clients
Throughput test
messages per seconds: 58,864</p>

<p>Latency test at 30,000 msg/sec
50% / 90% / 99% // 99.9% / 99.99% / worst latency was 33 / 80 / 111 // 120 / 148 / 3,921 us</p>

<p>4 clients
Throughput test
messages per seconds: 94,006</p>

<p>Latency test at 30,000 msg/sec
50% / 90% / 99% // 99.9% / 99.99% / worst latency was 32 / 94 / 106 // 131 / 177 / 2,153 us</p>

<p>8 clients
Throughput test
messages per seconds: 162,961</p>

<p>Latency test at 30,000 msg/sec
50% / 90% / 99% // 99.9% / 99.99% / worst latency was 35 / 94 / 117 // 140 / 167 / 1,685 us</p>

<p>16 clients
Throughput test
messages per seconds: 267,097</p>

<p>Latency test at 30,000 msg/sec
50% / 90% / 99% // 99.9% / 99.99% / worst latency was 38 / 97 / 122 // 149 / 174 / 2,771 us</p>

<p>24 clients
Throughput test
messages per seconds: 253,052</p>

<p>Latency test at 30,000 msg/sec
50% / 90% / 99% // 99.9% / 99.99% / worst latency was 40 / 99 / 121 // 151 / 243 / 3,669 us</p>

<h5>
<a id="close-1" class="anchor" href="#close-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Close</h5>

<p>its always important to close <code>ChronicleMap</code>'s and <code>ChronicleSet</code> 's when you have finished with them</p>

<div class="highlight highlight-java"><pre>serverMap<span class="pl-k">.</span>close();
statelessMap<span class="pl-k">.</span>close();</pre></div>

<h1>
<a id="known-issues" class="anchor" href="#known-issues" aria-hidden="true"><span class="octicon octicon-link"></span></a>Known Issues</h1>

<h5>
<a id="memory-issue-on-windows" class="anchor" href="#memory-issue-on-windows" aria-hidden="true"><span class="octicon octicon-link"></span></a>Memory issue on Windows</h5>

<p>ChronicleMap lets you assign a map larger than your available memory, If you were to create more
entries than the available memory, ChronicleMap will page the segments that are accessed least to
disk, and load the recently used segments into available memory. This feature lets you work with
extremely large maps, it works brilliantly on Linux but unfortunately, this paging feature is not
supported on Windows, if you use more memory than is physically available on windows you will
experience the following error :</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">Java</span> frames<span class="pl-k">:</span> (<span class="pl-stj">J</span><span class="pl-k">=</span>compiled <span class="pl-stj">Java</span> code, j<span class="pl-k">=</span>interpreted, <span class="pl-stj">Vv</span><span class="pl-k">=</span><span class="pl-c1">VM</span> code)
j <span class="pl-stj">sun.misc<span class="pl-k">.</span>Unsafe</span><span class="pl-k">.</span>compareAndSwapLong(<span class="pl-stj">Ljava</span><span class="pl-k">/</span>lang<span class="pl-k">/</span><span class="pl-stj">Object</span>;<span class="pl-c1">JJJ</span>)<span class="pl-stj">Z</span><span class="pl-k">+</span><span class="pl-c1">0</span>
j <span class="pl-stj">net.openhft.lang.io<span class="pl-k">.</span>NativeBytes</span><span class="pl-k">.</span>compareAndSwapLong(<span class="pl-c1">JJJ</span>)<span class="pl-stj">Z</span><span class="pl-k">+</span><span class="pl-c1">13</span>
j <span class="pl-stj">net.openhft.lang.io<span class="pl-k">.</span>AbstractBytes</span><span class="pl-k">.</span>tryLockNanos8a(<span class="pl-c1">JJ</span>)<span class="pl-stj">Z</span><span class="pl-k">+</span><span class="pl-c1">12</span>
j <span class="pl-stj">net.openhft.lang.io<span class="pl-k">.</span>AbstractBytes</span><span class="pl-k">.</span>tryLockNanosLong(<span class="pl-c1">JJ</span>)<span class="pl-stj">Z</span><span class="pl-k">+</span><span class="pl-c1">41</span>
j <span class="pl-stj">net.openhft.collections<span class="pl-k">.</span>AbstractVanillaSharedHashMap</span>$<span class="pl-stj">Segment</span><span class="pl-k">.</span>lock()<span class="pl-stj">V</span><span class="pl-k">+</span><span class="pl-c1">12</span></pre></div>

<h5>
<a id="when-chronicle-map-is-full" class="anchor" href="#when-chronicle-map-is-full" aria-hidden="true"><span class="octicon octicon-link"></span></a>When Chronicle Map is Full</h5>

<p>It will throw this exception :</p>

<div class="highlight highlight-java"><pre><span class="pl-stj">Caught</span><span class="pl-k">:</span> <span class="pl-stj">java.lang<span class="pl-k">.</span>IllegalStateException</span><span class="pl-k">:</span> <span class="pl-stj">VanillaShortShortMultiMap</span> is full
<span class="pl-stj">java.lang<span class="pl-k">.</span>IllegalStateException</span><span class="pl-k">:</span> <span class="pl-stj">VanillaShortShortMultiMap</span> is full
    at <span class="pl-stj">net.openhft.collections<span class="pl-k">.</span>VanillaShortShortMultiMap</span><span class="pl-k">.</span>nextPos(<span class="pl-stj">VanillaShortShortMultiMap</span><span class="pl-k">.</span>java<span class="pl-k">:</span><span class="pl-c1">226</span>)
    at <span class="pl-stj">net.openhft.collections<span class="pl-k">.</span>AbstractVanillaSharedHashMap</span>$<span class="pl-stj">Segment</span><span class="pl-k">.</span>put(<span class="pl-stj">VanillaSharedHashMap</span><span class="pl-k">.</span>java<span class="pl-k">:</span><span class="pl-c1">834</span>)
    at <span class="pl-stj">net.openhft.collections<span class="pl-k">.</span>AbstractVanillaSharedHashMap</span><span class="pl-k">.</span>put0(<span class="pl-stj">VanillaSharedHashMap</span><span class="pl-k">.</span>java<span class="pl-k">:</span><span class="pl-c1">348</span>)
    at <span class="pl-stj">net.openhft.collections<span class="pl-k">.</span>AbstractVanillaSharedHashMap</span><span class="pl-k">.</span>put(<span class="pl-stj">VanillaSharedHashMap</span><span class="pl-k">.</span>java<span class="pl-k">:</span><span class="pl-c1">330</span>)</pre></div>

<p>ChronicleMap doesn't resize automatically.  It is assumed you will make the virtual size of the map
larger than you need and it will handle this reasonably efficiently. With the default settings you
will run out of space between 1 and 2 million entries.</p>

<p>You should set the .entries(..) and .entrySize(..) to those you require.</p>

<h5>
<a id="dont-forget-to-set-the-entrysize" class="anchor" href="#dont-forget-to-set-the-entrysize" aria-hidden="true"><span class="octicon octicon-link"></span></a>Don't forget to set the EntrySize</h5>

<p>If you put() and entry that is much larger than the max entry size set via entrySize(), 
the code will error. To see how to set the entry size the example below sets the entry size to 10, 
you should pick a size that is the size in bytes of your entries : </p>

<div class="highlight highlight-java"><pre><span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">String</span>&gt;</span> map <span class="pl-k">=</span>
             <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">String</span><span class="pl-k">.</span>class)
                     .entrySize(<span class="pl-c1">10</span>)<span class="pl-k">.</span>create();
</pre></div>

<p>This example will throw an java.lang.IllegalArgumentException because the entrySize is too small.</p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">Test</span>
<span class="pl-s">public</span> <span class="pl-st">void</span> test() throws <span class="pl-stj">IOException</span>, <span class="pl-stj">InterruptedException</span> {
    <span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">String</span>&gt;</span> map <span class="pl-k">=</span>
            <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">String</span><span class="pl-k">.</span>class)
                    .entrySize(<span class="pl-c1">10</span>)<span class="pl-k">.</span>create();

    <span class="pl-stj">String</span> value <span class="pl-k">=</span>   <span class="pl-k">new</span> <span class="pl-stj">String</span>(<span class="pl-k">new</span> <span class="pl-stj">char</span>[<span class="pl-c1">2000</span>]);
    map<span class="pl-k">.</span>put(<span class="pl-c1">1</span>, value);

    <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertEquals(value, map<span class="pl-k">.</span>get(<span class="pl-c1">1</span>));
}
</pre></div>

<p>If the entry size is dramatically too small ( like in the example below ), 
you will get a <em>malloc_error_break</em> :</p>

<div class="highlight highlight-java"><pre>@<span class="pl-stj">Test</span>
<span class="pl-s">public</span> <span class="pl-st">void</span> test() throws <span class="pl-stj">IOException</span>, <span class="pl-stj">InterruptedException</span> {
    <span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">String</span>&gt;</span> map <span class="pl-k">=</span>
            <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">String</span><span class="pl-k">.</span>class)
                    .entrySize(<span class="pl-c1">10</span>)<span class="pl-k">.</span>create();

    <span class="pl-stj">String</span> value <span class="pl-k">=</span>   <span class="pl-k">new</span> <span class="pl-stj">String</span>(<span class="pl-k">new</span> <span class="pl-stj">char</span>[<span class="pl-c1">20000000</span>]);
    map<span class="pl-k">.</span>put(<span class="pl-c1">1</span>, value);

    <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertEquals(value, map<span class="pl-k">.</span>get(<span class="pl-c1">1</span>));
}</pre></div>

<h1>
<a id="example--simple-hello-world" class="anchor" href="#example--simple-hello-world" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example : Simple Hello World</h1>

<p>This simple chronicle map, works just like ConcurrentHashMap but stores its data off-heap. If you
want to use Chronicle Map to share data between java process you should look at the next exampl </p>

<div class="highlight highlight-java"><pre><span class="pl-st">Map&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class,
        <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>create();

map<span class="pl-k">.</span>put(<span class="pl-c1">1</span>, <span class="pl-s1"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>);
<span class="pl-stj">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(map<span class="pl-k">.</span>get(<span class="pl-c1">1</span>));
</pre></div>

<h1>
<a id="example--sharing-the-map-on-two--or-more--processes-on-the-same-machine" class="anchor" href="#example--sharing-the-map-on-two--or-more--processes-on-the-same-machine" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example : Sharing the map on two ( or more ) processes on the same machine</h1>

<p>Lets assume that we had two server, lets call them server1 and server2, if we wished to share a map
between them, this is how we could set it up</p>

<div class="highlight highlight-java"><pre>
<span class="pl-c">// --- RUN ON ONE JAVA PROCESS ( BUT ON THE SAME SERVER )</span>
{
    <span class="pl-stj">File</span> file <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">File</span>(<span class="pl-s1"><span class="pl-pds">"</span>a-new-file-on-your-sever<span class="pl-pds">"</span></span>);   
    <span class="pl-st">Map&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map1 <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
            .createPersistedTo(file); <span class="pl-c">// this has to be the same file as used by map 2</span>
    map1<span class="pl-k">.</span>put(<span class="pl-c1">1</span>, <span class="pl-s1"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>);
}

<span class="pl-c">// --- RUN ON THE OTHER JAVA PROCESS ( BUT ON THE SAME SERVER )</span>
{
    <span class="pl-stj">File</span> file <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-stj">File</span>(<span class="pl-s1"><span class="pl-pds">"</span>a-new-file-on-your-sever<span class="pl-pds">"</span></span>);  <span class="pl-c">// this has to be the same file as used by map 1</span>
    <span class="pl-st">Map&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map1 <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
            .createPersistedTo(file);

    <span class="pl-stj">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(map1<span class="pl-k">.</span>get(<span class="pl-c1">1</span>));
}</pre></div>

<h1>
<a id="example--replicating-data-between-process-on-different-servers-via-tcpip" class="anchor" href="#example--replicating-data-between-process-on-different-servers-via-tcpip" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example : Replicating data between process on different servers via TCP/IP</h1>

<p>Lets assume that we had two server, lets call them server1 and server2, if we wished to share a map
between them, this is how we could set it up</p>

<div class="highlight highlight-java"><pre><span class="pl-k">import</span> <span class="pl-smi">org.junit.Assert</span>;
<span class="pl-k">import</span> <span class="pl-smi">org.junit.Test</span>;

<span class="pl-k">import</span> <span class="pl-smi">java.io.IOException</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.net.InetSocketAddress</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Map</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.concurrent.TimeUnit</span>;

<span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">YourClass</span> {

    <span class="pl-st">@Test</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">test</span>() <span class="pl-s">throws</span> <span class="pl-stj">IOException</span>, <span class="pl-stj">InterruptedException</span> {

        <span class="pl-stj">Map</span> map1;
        <span class="pl-stj">Map</span> map2;

<span class="pl-c">//  ----------  SERVER1 1 ----------</span>
        {

            <span class="pl-c">// we connect the maps via a TCP/IP socket connection on port 8077</span>

            <span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span> <span class="pl-stj">TcpTransportAndNetworkConfig</span>
                    .of(<span class="pl-c1">8076</span>, <span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8077</span>))
                    .heartBeatInterval(<span class="pl-c1">1L</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>SECONDS</span>);
            <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map1Builder <span class="pl-k">=</span>
                    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
                            .entries(<span class="pl-c1">20000L</span>)
                            .replication((<span class="pl-st">byte</span>) <span class="pl-c1">1</span>, tcpConfig);

            map1 <span class="pl-k">=</span> map1Builder<span class="pl-k">.</span>create();
        }
<span class="pl-c">//  ----------  SERVER2 on the same server as ----------</span>

        {
            <span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span>
                    <span class="pl-stj">TcpTransportAndNetworkConfig</span><span class="pl-k">.</span>of(<span class="pl-c1">8077</span>)
                    .heartBeatInterval(<span class="pl-c1">1L</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>SECONDS</span>);
            <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map2Builder <span class="pl-k">=</span>
                    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
                            .entries(<span class="pl-c1">20000L</span>)
                            .replication((<span class="pl-st">byte</span>) <span class="pl-c1">2</span>, tcpConfig);
            map2 <span class="pl-k">=</span> map2Builder<span class="pl-k">.</span>create();

            <span class="pl-c">// we will stores some data into one map here</span>
            map2<span class="pl-k">.</span>put(<span class="pl-c1">5</span>, <span class="pl-s1"><span class="pl-pds">"</span>EXAMPLE<span class="pl-pds">"</span></span>);
        }

<span class="pl-c">//  ----------  CHECK ----------</span>

<span class="pl-c">// we are now going to check that the two maps contain the same data</span>

<span class="pl-c">// allow time for the recompilation to resolve</span>
        <span class="pl-st">int</span> t <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; t <span class="pl-k">&lt;</span> <span class="pl-c1">5000</span>; t<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (map1<span class="pl-k">.</span>equals(map2))
                <span class="pl-k">break</span>;
            <span class="pl-stj">Thread</span><span class="pl-k">.</span>sleep(<span class="pl-c1">1</span>);
        }

        <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertEquals(map1, map2);
        <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertTrue(<span class="pl-k">!</span>map1<span class="pl-k">.</span>isEmpty());
    }

}</pre></div>

<h1>
<a id="example--replicating-data-between-process-on-different-servers-using-udp" class="anchor" href="#example--replicating-data-between-process-on-different-servers-using-udp" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example : Replicating data between process on different servers using UDP</h1>

<p>This example is the same as the one above, but it uses a slow throttled TCP/IP connection to fill in
updates that may have been missed when sent over UDP. Usually on a good network, for example a wired
LAN, UDP won’t miss updates. But UDP does not support guaranteed delivery, we recommend also running
a TCP connection along side to ensure the data becomes eventually consistent.  Note : It is possible
to use Chronicle without the TCP replication and just use UDP (  that’s if you like living dangerously ! )</p>

<div class="highlight highlight-java"><pre><span class="pl-k">import</span> <span class="pl-smi">org.junit.Assert</span>;
<span class="pl-k">import</span> <span class="pl-smi">org.junit.Test</span>;

<span class="pl-k">import</span> <span class="pl-smi">java.io.IOException</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.net.Inet4Address</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.net.InetSocketAddress</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Map</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.concurrent.TimeUnit</span>;

<span class="pl-s">public</span> <span class="pl-s">class</span> <span class="pl-en">YourClass</span> {

    <span class="pl-st">@Test</span>
    <span class="pl-s">public</span> <span class="pl-st">void</span> <span class="pl-en">test</span>() <span class="pl-s">throws</span> <span class="pl-stj">IOException</span>, <span class="pl-stj">InterruptedException</span> {

        <span class="pl-stj">Map</span> map1;
        <span class="pl-stj">Map</span> map2;

        <span class="pl-st">int</span> udpPort <span class="pl-k">=</span> <span class="pl-c1">1234</span>;

<span class="pl-c">//  ----------  SERVER1 1 ----------</span>
        {

            <span class="pl-c">// we connect the maps via a TCP socket connection on port 8077</span>

            <span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span> <span class="pl-stj">TcpTransportAndNetworkConfig</span>
                    .of(<span class="pl-c1">8076</span>, <span class="pl-k">new</span> <span class="pl-stj">InetSocketAddress</span>(<span class="pl-s1"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8077</span>))
                    .heartBeatInterval(<span class="pl-c1">1L</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>SECONDS</span>)

                            <span class="pl-c">// a maximum of 1024 bits per millisecond</span>
                    .throttlingConfig(<span class="pl-stj">ThrottlingConfig</span><span class="pl-k">.</span>throttle(<span class="pl-c1">1024</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>MILLISECONDS</span>));

            <span class="pl-stj">UdpTransportConfig</span> udpConfig <span class="pl-k">=</span> <span class="pl-stj">UdpTransportConfig</span>
                    .of(<span class="pl-stj">Inet4Address</span><span class="pl-k">.</span>getByName(<span class="pl-s1"><span class="pl-pds">"</span>255.255.255.255<span class="pl-pds">"</span></span>), udpPort);

            <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map1Builder <span class="pl-k">=</span>
                    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
                            .entries(<span class="pl-c1">20000L</span>)
                            .replication(<span class="pl-stj">SingleChronicleHashReplication</span><span class="pl-k">.</span>builder()
                                    .tcpTransportAndNetwork(tcpConfig)
                                    .udpTransport(udpConfig)
                                    .createWithId((<span class="pl-st">byte</span>) <span class="pl-c1">1</span>));

            map1 <span class="pl-k">=</span> map1Builder<span class="pl-k">.</span>create();
        }
<span class="pl-c">//  ----------  SERVER2 2 on the same server as ----------</span>

        {
            <span class="pl-stj">TcpTransportAndNetworkConfig</span> tcpConfig <span class="pl-k">=</span>
                    <span class="pl-stj">TcpTransportAndNetworkConfig</span><span class="pl-k">.</span>of(<span class="pl-c1">8077</span>)
                    .heartBeatInterval(<span class="pl-c1">1L</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>SECONDS</span>)
                    .throttlingConfig(<span class="pl-stj">ThrottlingConfig</span><span class="pl-k">.</span>throttle(<span class="pl-c1">1024</span>, <span class="pl-stj">TimeUnit</span><span class="pl-c1"><span class="pl-k">.</span>MILLISECONDS</span>));

            <span class="pl-stj">UdpTransportConfig</span> udpConfig <span class="pl-k">=</span> <span class="pl-stj">UdpTransportConfig</span>
                    .of(<span class="pl-stj">Inet4Address</span><span class="pl-k">.</span>getByName(<span class="pl-s1"><span class="pl-pds">"</span>255.255.255.255<span class="pl-pds">"</span></span>), udpPort);

            <span class="pl-st">ChronicleMapBuilder&lt;<span class="pl-stj">Integer</span>, <span class="pl-stj">CharSequence</span>&gt;</span> map2Builder <span class="pl-k">=</span>
                    <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class, <span class="pl-stj">CharSequence</span><span class="pl-k">.</span>class)
                            .entries(<span class="pl-c1">20000L</span>)
                            .replication(<span class="pl-stj">SingleChronicleHashReplication</span><span class="pl-k">.</span>builder()
                                    .tcpTransportAndNetwork(tcpConfig)
                                    .udpTransport(udpConfig)
                                    .createWithId((<span class="pl-st">byte</span>) <span class="pl-c1">2</span>));

            map2 <span class="pl-k">=</span> map2Builder<span class="pl-k">.</span>create();

            <span class="pl-c">// we will stores some data into one map here</span>
            map2<span class="pl-k">.</span>put(<span class="pl-c1">5</span>, <span class="pl-s1"><span class="pl-pds">"</span>EXAMPLE<span class="pl-pds">"</span></span>);
        }

<span class="pl-c">//  ----------  CHECK ----------</span>

<span class="pl-c">// we are now going to check that the two maps contain the same data</span>

<span class="pl-c">// allow time for the recompilation to resolve</span>
        <span class="pl-st">int</span> t <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (; t <span class="pl-k">&lt;</span> <span class="pl-c1">5000</span>; t<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (map1<span class="pl-k">.</span>equals(map2))
                <span class="pl-k">break</span>;
            <span class="pl-stj">Thread</span><span class="pl-k">.</span>sleep(<span class="pl-c1">1</span>);
        }

        <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertEquals(map1, map2);
        <span class="pl-stj">Assert</span><span class="pl-k">.</span>assertTrue(<span class="pl-k">!</span>map1<span class="pl-k">.</span>isEmpty());
    }
}</pre></div>

<h1>
<a id="example--creating-a-chronicle-set-and-adding-data-to-it" class="anchor" href="#example--creating-a-chronicle-set-and-adding-data-to-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example : Creating a Chronicle Set and adding data to it</h1>

<p>This project also provides the Chronicle Set, <code>ChronicleSet</code> is built on Chronicle Map, so the builder
configuration are almost identical to <code>ChronicleMap</code> ( see above ), this example shows how to create
a simple off heap set</p>

<div class="highlight highlight-java"><pre>        <span class="pl-st">Set&lt;<span class="pl-stj">Integer</span>&gt;</span> set <span class="pl-k">=</span> <span class="pl-stj">ChronicleSetBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Integer</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>create();

        set<span class="pl-k">.</span>add(<span class="pl-c1">1</span>);
        set<span class="pl-k">.</span>remove(<span class="pl-c1">1</span>)</pre></div>

<p>and just like map it support shared memory and TCP replication.         </p>

<h1>
<a id="performance-topics-1" class="anchor" href="#performance-topics-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance Topics</h1>

<p>There are general principles we can give direction on - for specific advise we believe consulting
 to be the most productive solution.</p>

<p>We want the Map to be reasonably general purpose, so in broad terms we can say</p>

<ul>
<li>the key and values have to be self contained, ideally trees, rather than graphs.</li>
<li>ideally values are similar lengths, however we support varying lengths.</li>
<li>ideally you want to use primitives and use object recycling for performance, though this is not a requirement.</li>
<li>ideally you have some idea as to the maximum number of entries, though it is not too important if
the maximum entries is above what you need.</li>
<li>if for example you are working with, market depth, this  can be supported via an array of nested 
types.</li>
<li>we support code generation of efficient custom serializes - See the examples where you provide 
an interface as the data type, the map will generate the implementation.</li>
</ul>

<h3>
<a id="improving-the-performance-of-chronicle-maps-serialization" class="anchor" href="#improving-the-performance-of-chronicle-maps-serialization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Improving the performance of Chronicle Maps Serialization</h3>

<p>Are you finding that when using Chronicle Map the serialisation is slow, but you have a large object graph,
if so -
here are some steps that you can take to improve performance ( you may find that just one of these steps gives you the performance you require )</p>

<ul>
<li>consider replacing java.io.Serializable with java.io.Externalizable ( java.io.Externalizable can be much
faster, but requires you do the the serialisation your self)</li>
<li>consider using net.openhft.lang.io.serialization.BytesMarshallable, working with this is like using java
.io.Externalizable but in addition is supports some compressed types, which can give you slightly better performance.</li>
<li>try where possible to de-normalize your object graph, if you are able to limit your graph down to just a
few types you can then look at using our off heap interface proxy objects and have a map instance per type
of object
( much like in a database where you would have a table per type ), you could then set up foreign key
relationships between the maps, by using for example integers or longs. This works especially well as
integers and longs have a good hash distribution.</li>
</ul>

<h3>
<a id="tuning-chronicle-map-with-large-data" class="anchor" href="#tuning-chronicle-map-with-large-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tuning Chronicle Map with Large Data</h3>

<p>Generally speaking <code>ChronicleMap</code> is slower then ConcurrentHashMap for a small number of entries, but
for a large number of entries ConcurrentHashMap doesn't scale as well as Chronicle Map, especially
when you start running low on heap. ConcurrentHashMap quickly becomes unusable whereas Chronicle Map
can still work when it is 20 times the size of a ConcurrentHashMap with an Out of Memory Error.</p>

<p>For example with a heap of 3/4 of say 32 GB main memory, you might get say 100 million entries but
when using most of the heap you might see 20-40 second gc pauses with <code>ChronicleMap</code> you could have
1000 million entries and see &lt; 100 ms pauses (depending on your disk subsystem and how fast you
write your data)</p>

<p>Chronicle Map makes heavy use of the OS to perform the memory management and writing to disk. How it
behaves is very dependant on how you tune the kernel and what hardware you are using. You may get
bad behaviour when the kernel forces a very large amount of data to disk after letting a lot of
uncommited data build up. In the worst case scenario the OS will stop the process for tens of
seconds at a time ( even up to 40 seconds) rather than let the program continue. However, to get
into that state you have to be loading a lot of data which exceeds main memory with very little rest
(e.g. cpu processing). There are good use cases for bulk data loads, but you have to be careful how
this is done if you also want good worst case latency characteristics. (the throughput should be
much the same)</p>

<p>When you create a ChronicleMap, it has many segments. By default it has a minimum of 128, but one
for every 32 K entries. e.g. for 500M entries you can expect ~16K segments (being the next power of
2). With so many segments, the chances of a perfect hash distribution is low and so the Chronicle
Map allows for double what you asked for but is designed to do this with almost no extra main memory
(only extra virtual memory). This means when you ask for 500M * 256 bytes entries you actually get 1
BN possible entries (assuming a perfect hash distribution between segments) There is a small
overhead per entry of 16 - 24 bytes adding another 20 GB.</p>

<p>So while the virtual memory is 270 GB, it is expected that for 500 M entries you will be trying to
use no more than 20 GB (overhead/hash tables) + ~120 GB (entries)</p>

<p>When <code>ChronicleMap</code> has exhausted all the memory on your server, its not going to be so fast, for a
random access pattern you are entirely dependant on how fast your underlying disk is. If your home
directory is an HDD and its performance is around 125 IOPS (I/Os per second). Each lookup takes two
memory accesses so you might get around 65 lookups per second. For 100-200K operations you can
expect around 1600 seconds or 25-50 minutes. If you use an SSD, it can get around 230 K IOPS, or
about 115 K <code>ChronicleMap</code> lookups per second.</p>

<h3>
<a id="lock-contention" class="anchor" href="#lock-contention" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lock contention</h3>

<p>If you see the following warning :</p>

<div class="highlight highlight-java"><pre><span class="pl-c1">WARNING</span><span class="pl-k">:</span><span class="pl-stj">net.openhft.lang.io<span class="pl-k">.</span>AbstractBytes</span> tryLockNanosLong0
<span class="pl-c1">WARNING</span><span class="pl-k">:</span> <span class="pl-stj">Thread</span><span class="pl-k">-</span><span class="pl-c1">2</span>, to obtain a lock took <span class="pl-c1">0.129</span> seconds</pre></div>

<p>It's likely you have lock contention, this can be due to : </p>

<ul>
<li>a low number of segments and</li>
<li>the machine was heavily over utilised, possibly with the working data set larger than main memory.</li>
<li>you have a large number of threads, greater than the number of cores you have, doing nothing but hit one map.</li>
</ul>

<p>It’s not possible to fully disable locking,  locking is done a a segment basis.
So, If you set a large number of actual segments, this will reduce your lock contention. </p>

<p>See the example below to see how to set the number of segments :</p>

<div class="highlight highlight-java"><pre><span class="pl-st">ChronicleMap&lt;<span class="pl-stj">Long</span>, <span class="pl-stj">String</span>&gt;</span> map <span class="pl-k">=</span> <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">Long</span><span class="pl-k">.</span>class, <span class="pl-stj">String</span><span class="pl-k">.</span>class)
   .entries(<span class="pl-c1">100</span>)
   .actualSegments(<span class="pl-c1">100</span>)    <span class="pl-c">// set your number of segments here</span>
   .create();</pre></div>

<p>Reducing lock contention will make this warning message go away, but this message maybe more of a symptom 
of a general problem with what the system is doing, so you may experience a delay anyway.</p>

<h3>
<a id="better-to-use-small-keys" class="anchor" href="#better-to-use-small-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Better to use small keys</h3>

<p>If you put() a small number of large entries into ChronicleMap, you are unlikely to see any
performance gains over a standard map, So we recommend you use a standard ConcurrentHashMap, unless
you need ChronicleMaps other features.</p>

<p>Chronicle Map gives better performance for smaller keys and values due to the low overhead per
entry. It can use 1/5th the memory of ConcurrentHashMap. When you have larger entries, the overhead
per entry doesn't matter so much and the relative waste per entry starts to matter. For Example,
ChronicleMap assumes every entry is the same size and if you have 10kB-20kB entries the 10K entries
can be using 20 kB of virtual memory or at least 12 KB of actual memory (since virtual memory turns
into physical memory in multiples of a page)</p>

<p>As the <code>ChronicleMap</code> gets larger the most important factor is the use of CPU cache rather than main
memory, performance is constrained by the number of cache lines you have to touch to update/read an
entry. For large entries this is much the same as ConcurrentHashMap.  In this case, <code>ChronicleMap</code> is
not worse than ConcurrentHashMap but not much better.</p>

<p>For large key/values it is not total memory use but other factors which matter such as;</p>

<ul>
<li>how compact each entry is. Less memory used makes better use of the L3 cache and memory bus which
is often a bottleneck in highly concurrent applications. </li>
<li>reduce the impact on GCs. The time to perform  GC and its impact is linear. Moving the bulk of
your data off heap can dramatically improve throughput not to mention worst case latency.</li>
<li>Large data structures take a long time to reload and having a persisted store significantly
reduces restart times.</li>
<li>data can be shared between processes. This gives you more design options to share between JVMS and
support short lived tasks without having to use TCP.</li>
<li>data can be replicated across machines.</li>
</ul>

<h3>
<a id="concurrenthashmap-v-chroniclemap" class="anchor" href="#concurrenthashmap-v-chroniclemap" aria-hidden="true"><span class="octicon octicon-link"></span></a>ConcurrentHashMap v ChronicleMap</h3>

<p>ConcurrentHashMap ( CHM ) outperforms <code>ChronicleMap</code> ( CM ) on throughput.  If you don't need
the extra features ChronicleMap gives you, it is not worth the extra complexity it brings.
i.e. don't use it just because you think it is cool. The test can be found in
<a href="https://github.com/OpenHFT/Chronicle-Map/blob/master/src/test/java/net/openhft/chronicle/map/ChronicleMapTest.java">ChronicleMapTest</a>
under testAcquirePerf() and testCHMAcquirePerf()</p>

<p>ChronicleMap outperforms ConcurrentHashMap on memory consumption, and worst case latencies.
It can be used to reduce or eliminate GCs.</p>

<h4>
<a id="performance-test-for-many-small-key-values" class="anchor" href="#performance-test-for-many-small-key-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance Test for many small key-values</h4>

<p>The following performance test consists of string keys of the form "u:0123456789" and an int
counter.  The update increments the counter once in each thread, creating an new entry if required.</p>

<table>
<thead>
<tr>
<th align="right">Number of entries</th>
<th align="right">Chronicle* Throughput</th>
<th align="right">Chronicle RSS</th>
<th align="right">HashMap* Throughput</th>
<th align="right">HashMap Worst GC pause</th>
<th align="right">HashMap RSS</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">10 million</td>
<td align="right">30 Mupd/s</td>
<td align="right">½ GB</td>
<td align="right">155 Mupd/s</td>
<td align="right">2.5 secs</td>
<td align="right">9 GB</td>
</tr>
<tr>
<td align="right">50 million</td>
<td align="right">31 Mupd/s</td>
<td align="right">3⅓ GB</td>
<td align="right">120 Mupd/s</td>
<td align="right">6.9 secs</td>
<td align="right">28 GB</td>
</tr>
<tr>
<td align="right">250 million</td>
<td align="right">30 Mupd/s</td>
<td align="right">14 GB</td>
<td align="right">114 Mupd/s</td>
<td align="right">17.3 secs</td>
<td align="right">76 GB</td>
</tr>
<tr>
<td align="right">1000 million</td>
<td align="right">24 Mupd/s</td>
<td align="right">57 GB</td>
<td align="right">OOME</td>
<td align="right">43 secs</td>
<td align="right">NA</td>
</tr>
<tr>
<td align="right">2500 million</td>
<td align="right">23 Mupd/s</td>
<td align="right">126 GB</td>
<td align="right">Did not test</td>
<td align="right">NA</td>
<td align="right">NA</td>
</tr>
</tbody>
</table>

<p><em>*HashMap refers to ConcurrentHashMap, Chronicle refers to Chronicle Map</em></p>

<p>Key :
RSS - Resident memory size.  How much main memory was used.
Mupd/s - Million write operations per second. i.e. put(key, value);</p>

<p>Notes:</p>

<ul>
<li>
<code>ChronicleMap</code> was tested with a 32 MB heap, CHM was test with a 100 GB heap.</li>
<li>The <code>ChronicleMap</code> test had a small minor GC on startup of 0.5 ms, but not during the test.
This is being investigated.</li>
<li>
<code>ChronicleMap</code> was tested "writing" to a tmpfs file system.</li>
</ul>

<h4>
<a id="how-does-it-perform-when-persisted" class="anchor" href="#how-does-it-perform-when-persisted" aria-hidden="true"><span class="octicon octicon-link"></span></a>How does it perform when persisted?</h4>

<p>Chronicle Map also supports persistence. In this regard there is no similar class in the JDK.</p>

<table>
<thead>
<tr>
<th align="right">Number of entries</th>
<th align="right">Chronicle Throughput</th>
<th align="right">Chronicle RSS</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">10 million</td>
<td align="right">28 Mupd/s</td>
<td align="right">½ GB</td>
</tr>
<tr>
<td align="right">50 million</td>
<td align="right">28 Mupd/s</td>
<td align="right">9 GB</td>
</tr>
<tr>
<td align="right">250 million</td>
<td align="right">26 Mupd/s</td>
<td align="right">24 GB</td>
</tr>
<tr>
<td align="right">1000 million</td>
<td align="right">1.3 Mupd/s</td>
<td align="right">85 GB</td>
</tr>
</tbody>
</table>

<p>Notes:</p>

<ul>
<li>Persistence was performed at a PCI-SSD which supports up to 230K IOPS and 900 MB/s write speed.
This test didn't test the card to it's limit until the last test.</li>
<li>The kernel tuning parameters for write back are important here.
This explains the suddern drop off and this is being investigated.</li>
</ul>

<p>The sysctl parameters used were approximately 10x the defaults to allow as many operations
to be performed in memory as possible.</p>

<pre><code>vm.dirty_background_ratio = 50
vm.dirty_expire_centisecs = 30000
vm.dirty_ratio = 90
vm.dirty_writeback_centisecs = 5000
</code></pre>

<h1>
<a id="questions-and-answers" class="anchor" href="#questions-and-answers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Questions and Answers</h1>

<h4>
<a id="question" class="anchor" href="#question" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>I'm searching for a Map implementation that is backed by either direct off-heap or a memory 
mapped file. I want to use it as write-once, read-n-times kind of cache.</p>

<h4>
<a id="answer" class="anchor" href="#answer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>The latest version of ChronicleMap has been optimised for this use case. Ie for heavy read to write ratios. 
Note: heavy writers will see about the same performance.</p>

<hr>

<h4>
<a id="question-1" class="anchor" href="#question-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>The backing of to off-heap is only needed to prevent OOM-situations. Otherwise the process  can use a big part of the available memory for the map.</p>

<h4>
<a id="answer-1" class="anchor" href="#answer-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>Chronicle Map can be larger than main memory. In fact you might want to reduce the heap size to give chronicle map more memory in extreme cases. Ie because the map can't utilise on heap memory much.</p>

<hr>

<h4>
<a id="question-2" class="anchor" href="#question-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>I stumbled over chronicle-map and it looks like it could do most of those things. Correct me if i'm wrong but</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// would create the off-heap version </span>
<span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">A</span><span class="pl-k">.</span>class, <span class="pl-stj">B</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>create();</pre></div>

<h4>
<a id="answer-2" class="anchor" href="#answer-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>Yes.</p>

<hr>

<h4>
<a id="question-3" class="anchor" href="#question-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<div class="highlight highlight-java"><pre><span class="pl-c">// the memory-mapped file version ?</span>
 <span class="pl-stj">ChronicleMapBuilder</span><span class="pl-k">.</span>of(<span class="pl-stj">A</span><span class="pl-k">.</span>class, <span class="pl-stj">B</span><span class="pl-k">.</span>class)<span class="pl-k">.</span>file(mapFile)<span class="pl-k">.</span>create();</pre></div>

<h4>
<a id="answer-3" class="anchor" href="#answer-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>Yes.</p>

<hr>

<h4>
<a id="question-4" class="anchor" href="#question-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>But both versions write the complete map at every single moment to off-heap, right ?</p>

<h4>
<a id="answer-4" class="anchor" href="#answer-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>Every key/value is off heap. There is no cache of objects on heap.</p>

<hr>

<h4>
<a id="question-5" class="anchor" href="#question-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>Is there something in chronicle map which can have part of the map-content still in on-heap memory.</p>

<h4>
<a id="answer-5" class="anchor" href="#answer-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>There are data structures which are on heap to manahe the off heap data. This is typically less than 100 kB.</p>

<hr>

<h4>
<a id="question-6" class="anchor" href="#question-6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>Either serialized or deserialized. Performance wise do you think that would even matter ?</p>

<h4>
<a id="answer-6" class="anchor" href="#answer-6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>It matter a lot but you can get the performance close to on heap objects without the long GC pause times. Ie only the bit on the heap makes any difference.</p>

<hr>

<h4>
<a id="question-7" class="anchor" href="#question-7" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>Last but not least... do you think chronicle is suitable for this simple purpose ?</p>

<h4>
<a id="answer-7" class="anchor" href="#answer-7" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>Actually this is all it does really. We try to make it fast by keeping it simple. 
Eg it is not a cache and doesn't have expiries etc. There is no background thread managing it.
In fact it is so simple that many methods are completely in lined. 
Ie if you look at a crash dump the chronicle methods have been completely in lined and don't appear in the stack trace any more. (The still appear in java stack traces)</p>

<hr>

<h4>
<a id="question-8" class="anchor" href="#question-8" aria-hidden="true"><span class="octicon octicon-link"></span></a>Question</h4>

<p>Or is there a lot of overhead for other functionality which i do not intend to use (yet) !?</p>

<h4>
<a id="answer-8" class="anchor" href="#answer-8" aria-hidden="true"><span class="octicon octicon-link"></span></a>Answer</h4>

<p>You can share the data between processes on the same machine but this doesn't add overhead.
You can add replication between machines. But this uses extra classes which are not used in the simple case ie it is as if they were not there, only an option.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/OpenHFT">OpenHFT</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>